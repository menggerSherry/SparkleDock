#include "prepare_gso_tasks.h"
#include "swarm_centers.h"
#include "fastdfire.h"
#include <iostream>
#include <random>
#include <cstdint>
#include "lib_tools.h"
#include <cmath>
#include <string.h>
#include <fstream>
#include "interface.h"
#include <sstream>
#include <iomanip>  // 包含设置小数点精度的头文件
#include "complex.h"
#include <algorithm>
#include <omp.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include "error.cuh"
#include "path_include.h"
#include <mma.h>
#include <cub/cub.cuh>
#include <cuda/std/tuple>
#include <cub/block/block_load.cuh>
#include <cub/block/block_store.cuh>
#include <cub/block/block_radix_sort.cuh>
#include <cub/device/device_radix_sort.cuh>
#include <cub/device/device_segmented_radix_sort.cuh>
#include <cub/util_macro.cuh>
#include <cub/util_math.cuh>
#include <cub/util_type.cuh>
#include <thrust/gather.h>
#include <thrust/iterator/zip_iterator.h>
#include <thrust/memory.h>
#include <thrust/scan.h>
#include <thrust/sequence.h>
#include <cute/tensor.hpp>
// using namespace nvcuda;
#define MAX_TRANSLATION 30
#define MAX_ROTATION 1.0
#define MIN_EXTENT 0.0
#define MAX_EXTENT 1.0
#define DEFAULT_NMODES_REC 10
#define DEFAULT_NMODES_LIG 10

#define STEPS 100
const unsigned int FULL_MASK=0xffffffff;
const int WMMA_M = 16;
const int WMMA_N = 16;
const int WMMA_K = 16;

namespace config{
    using namespace cute;
    template <int kTileM_ = 32, int kTileN_ = 32, int kTileK_ = 4>
    struct GemmConfig{
        // using T = T_;
        static constexpr int kTileM = kTileM_;
        static constexpr int kTileN = kTileN_;
        static constexpr int kTileK = kTileK_;



        using mma_op = SM80_8x8x4_F64F64F64F64_TN;
        using mma_traits = MMA_Traits<mma_op>;
        // 的到mma_atom 32 个线程
        using mma_atom = MMA_Atom<mma_traits>;
        using mma_atom_shape = mma_traits::Shape_MNK;
        using MMA = decltype(make_tiled_mma(mma_atom{}, 
                        make_layout(Shape<_2, _2, _1>{}), 
                        make_layout(Shape<_2, _2, _1>{})));
        using g2s_copy_op = SM80_CP_ASYNC_CACHEALWAYS<double>;
        using g2s_copy_traits = Copy_Traits<g2s_copy_op>;
        using g2s_copy_atom = Copy_Atom<g2s_copy_traits, double>;

        using G2SCopyA =
        decltype(make_tiled_copy(g2s_copy_atom{},
                                make_layout(make_shape(Int<32>{}, Int<4>{}),
                                            make_stride(Int<4>{}, Int<1>{})),
                                make_layout(make_shape(Int<1>{}, Int<1>{}))));
        
        using G2SCopyB = G2SCopyA;


        using S2GCopyAtomC = Copy_Atom<UniversalCopy<double>, double>;
        // using s2g_copy_traits = Copy_Traits<s2g_copy_op>;
        // using s2g_copy_atom = Copy_Atom<s2g_copy_traits, double>;

        using S2GCopyC = 
        decltype(make_tiled_copy(S2GCopyAtomC{},
                                make_layout(make_shape(Int<32>{}, Int<4>{}),
                                            make_stride(Int<4>{}, Int<1>{})),
                                make_layout(make_shape(Int<1>{}, Int<8>{}))));

        using s2r_copy_op = DefaultCopy;
        using s2r_copy_traits = Copy_Traits<s2r_copy_op>;
        using s2r_copy_atom = Copy_Atom<s2r_copy_traits, double>;

        using S2RCopyAtomA = s2r_copy_atom;
        using S2RCopyAtomB = s2r_copy_atom;
        static constexpr int block = size(MMA{});
    };
}


// energy_tmp
template <typename Config>
__global__ void 
calculate_dfire_tensorcore_cute(
    double * d_energy_tmp,
    double * d_receptor_pose, double * d_ligand_pose, 
    double * d_scoring_base, double * d_luciferin_base, double * d_rho_base, double * d_gamma_base, 
    int * d_moved_base, int * d_step_base,
    double * d_fastdfire,  int * rec_object, int * lig_object,
    int swarms, int num_glowworms, 
    int receptor_atoms, int ligand_atoms, int rec_tile, int lig_tile
){
    using namespace cute;
    // using X = Underscore;
    
    using TiledMMA = typename Config::MMA;
    using G2SCopyA = typename Config::G2SCopyA;
    using G2SCopyB = typename Config::G2SCopyB;
    using S2GCopyC = typename Config::S2GCopyC;
    using S2RCopyAtomA = typename Config::S2RCopyAtomA;
    using S2RCopyAtomB = typename Config::S2RCopyAtomB;

    constexpr int kTileM = Config::kTileM;
    constexpr int kTileN = Config::kTileN;
    constexpr int kTileK = Config::kTileK;
    
    // block 3 
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;

    __shared__ double s_mem[6000];

    double * Ashm = s_mem;
    double * Bshm = s_mem + 128;
    double * Cshm = s_mem + 256;
    double * Fshm = s_mem + 1281;
    

    double * current_ligand_pose = &d_ligand_pose[block_idz * num_glowworms * ligand_atoms * 4 + block_idy * ligand_atoms * 4];
    double * current_receptor_pose = &d_receptor_pose[block_idz * num_glowworms * receptor_atoms * 4 + block_idy * receptor_atoms * 4];
    // double * current_D_tmp = &D_tmp[block_idz * receptor_atoms * ligand_atoms];
    int moved = d_moved_base[block_idz * num_glowworms + block_idy];
    int steped = d_step_base[block_idz * num_glowworms + block_idy];

    double rho =  d_rho_base[block_idz * num_glowworms + block_idy];
    double luciferins = d_luciferin_base[block_idz * num_glowworms + block_idy];
    double gamma = d_gamma_base[block_idz * num_glowworms + block_idy];

    double * energy_ptr = &d_energy_tmp[block_idz * num_glowworms * receptor_atoms * lig_tile * 4 + block_idy * receptor_atoms * lig_tile * 4];
    // printf("test \n");
    // double energy = d_scoring_base[block_idz * block_sizey * block_size + block_idy * block_size];
    if((moved || steped == 0)){

    // global memory tensor
    Tensor A = make_tensor(make_gmem_ptr(current_receptor_pose), make_shape(receptor_atoms, 4), make_stride(4, Int<1>{}));
    // B layout 为行优先，tensor行加1stride加K
    Tensor B = make_tensor(make_gmem_ptr(current_ligand_pose), make_shape(ligand_atoms, 4), make_stride(4, Int<1>{}));

    Tensor C = make_tensor(make_gmem_ptr(energy_ptr), make_shape(receptor_atoms, lig_tile * 4), make_stride(lig_tile * 4, Int<1>{}));
    // C layout 为行优先， tensor行加1，stride加N
    // Tensor C = make_tensor(make_gmem_ptr(current_D_tmp), make_shape(receptor_atoms, ligand_atoms), make_stride(ligand_atoms, Int<1>{}));
    // Tensor D = make_tensor(make_gmem_ptr(current_D_tmp), make_shape(receptor_atoms, ligand_atoms), make_stride(ligand_atoms, Int<1>{}));
    // Tensor dfire_energy = make_tensor(make_gmem_ptr(fastdfire_opt), make_shape(receptor_atoms, ligand_atoms * 20), make_stride(ligand_atoms * 20, 1));

   
    // 首先对全局内存中的A划分tile ，tile的维度是M，K， 接下来根据block确定哪一个块
    Tensor gA = local_tile(A, make_tile(Int<kTileM>{}, Int<kTileK>{}), make_coord(block_idx / lig_tile, _));
    Tensor gB = local_tile(B, make_tile(Int<kTileN>{}, Int<kTileK>{}), make_coord(block_idx % lig_tile, _));
    Tensor gC = local_tile(C, make_tile(Int<kTileM>{}, Int<4>{}), make_coord(block_idx / lig_tile, block_idx % lig_tile));
    // Tensor gC = local_tile(C, make_tile(Int<kTileM>{}, Int<kTileN>{}), make_coord(block_idy, block_idx));
    // Tensor block_dfire = local_tile(dfire_energy, make_tile(Int<kTileM>{}, Int<kTileN*20>{}), make_coord(block_idx / lig_tile, (block_idx % lig_tile) * 20));
    // 8次copy


    // shared memory tensor
    auto sA = make_tensor(make_smem_ptr(Ashm),
                            make_shape(Int<kTileM>{}, Int<kTileK>{},Int<1>{}), make_stride(Int<kTileK>{}, Int<1>{}, Int<1>{}));  
    auto sB = make_tensor(make_smem_ptr(Bshm),
                            make_shape(Int<kTileN>{}, Int<kTileK>{},Int<1>{}), make_stride(Int<kTileK>{}, Int<1>{}, Int<1>{}));  
    auto sC = make_tensor(make_smem_ptr(Cshm),
                            make_shape(Int<kTileM>{}, Int<kTileN>{},Int<1>{}), make_stride(Int<kTileN>{}, Int<1>{}, Int<1>{}));
    auto sF = make_tensor(make_smem_ptr(Fshm),
                            make_shape(Int<4>{}, Int<kTileN*20>{}, Int<1>{}), make_stride(Int<kTileN*20>{}, Int<1>{}, Int<1>{}));
    
    // 根据mma划分tile
    TiledMMA tiled_mma;
    // 对shmem划分到线程
    auto thr_mma = tiled_mma.get_slice(threadIdx.x);
    auto tCsC = thr_mma.partition_C(sC);  // (MMA, MMA_M, MMA_N)
    auto tAsA = thr_mma.partition_A(sA);
    auto tBsB = thr_mma.partition_B(sB);
    // 对寄存器划分到线程
    auto tArA = thr_mma.partition_fragment_A(gA(_, _, 0));  // (MMA, MMA_M, MMA_K)
    auto tBrB = thr_mma.partition_fragment_B(gB(_, _, 0));  // (MMA, MMA_N, MMA_K)
    auto tCrC = thr_mma.partition_fragment_C(sC(_, _, 0));     // (MMA, MMA_M, MMA_N)
    // auto tCrD = thr_mma.partition_fragment_C(gD(_, _));     // (MMA, MMA_M, MMA_N)
    // auto tAsA =  thr_mma.partition_fragment_A(sA(_, _, 0));
    // auto tBsB =  thr_mma.partition_fragment_A(sB(_, _, 0));
    
    clear(tCrC);

    // 每个线程到共享内存拷贝划分
    G2SCopyA g2s_tiled_copy_a;
    auto g2s_thr_copy_a = g2s_tiled_copy_a.get_slice(thread_idx);
    auto tAgA_copy = g2s_thr_copy_a.partition_S(gA);  // (CPY, CPY_M, CPY_K, k)
    auto tAsA_copy =
      g2s_thr_copy_a.partition_D(sA);  // (CPY, CPY_M, CPY_K, kStage)

    G2SCopyB g2s_tiled_copy_b;
    auto g2s_thr_copy_b = g2s_tiled_copy_b.get_slice(thread_idx);
    auto tBgB_copy = g2s_thr_copy_b.partition_S(gB);  // (CPY, CPY_N, CPY_K, k)
    auto tBsB_copy =
        g2s_thr_copy_b.partition_D(sB);  // (CPY, CPY_N, CPY_K, kStage)

    S2GCopyC s2g_tiled_copy_c;


    // gmem-> smem
    cute::copy(g2s_tiled_copy_a, tAgA_copy(_, _, _, 0), tAsA_copy(_, _, _, 0));
    cute::copy(g2s_tiled_copy_b, tBgB_copy(_, _, _, 0), tBsB_copy(_, _, _, 0));
    cp_async_fence();
    cp_async_wait<0>();
    __syncthreads();

    // smem -> reg
    cute::copy(tAsA(_, _, _, 0), tArA);
    cute::copy(tBsB(_, _, _, 0), tBrB);
    // cute::copy(tCrD, tCgD);

    cute::gemm(tiled_mma, tCrC, tArA, tBrB, tCrC);

    // reg -> smem

    cute::copy(tCrC, tCsC(_,_,_,0));

    __syncthreads();

    // thread par
    Tensor gRow = local_tile(sA, make_shape(Int<1>{}, Int<kTileK>{}, Int<1>{}), make_coord(thread_idx / 4, _, 1));
    // 4 * 32
    Tensor gCol = local_tile(sB, make_shape(Int<kTileK*2>{}, Int<kTileK>{}, Int<1>{}), make_coord(thread_idx % 4, _, 1));
    // 对C进行分块
    Tensor g_tile = local_tile(sC, make_shape(Int<1>{}, Int<kTileK*2>{}, Int<1>{}), make_coord(thread_idx / 4, thread_idx % 4, 1));

    // Tensor gm_tile = local_tile(gC, make_shape(Int<1>{}, Int<kTileK*2>{}), make_coord(thread_idx / 4, thread_idx % 4));

    Tensor sthr_F = local_tile(sF, make_shape(Int<1>{}, Int<20>{}, Int<1>{}), make_coord(thread_idx/32, (thread_idx%32) * 20, 1));

    Tensor thr_C = local_tile(gC, make_shape(Int<1>{}, Int<1>{}), make_coord(thread_idx / 4, thread_idx % 4));

    // Tensor 
    

    auto R_fragment = make_tensor<double>(Shape<_1,_4>{});
    // auto gCr = make_tensor<double>(Shape<_1,_4>{});
    auto C_fragment = make_tensor<double>(Shape<_8,_4>{});

    auto til_fragment = make_tensor<double>(Shape<_1,_8>{});

    auto r_ener = make_tensor<double>(Shape<_1,_1>{});
    

    // smem -> reg
    cute::copy(gRow,R_fragment);
    cute::copy(gCol,C_fragment);
    cute::copy(g_tile,til_fragment);
    
#pragma unroll 
    for(int i = 0; i<size(til_fragment);i++){
        til_fragment(i) = til_fragment(i) * -2;
    }
    
    double sum = 0.0;
#pragma unroll
    for(int i = 0; i < 4; i++){
        sum = sum + R_fragment(i) * R_fragment(i);
    }
    R_fragment(0) = sum;




#pragma unroll
    for(int i = 0; i < 8; i++){
        til_fragment(i) = til_fragment(i) + R_fragment(0);
    }
// take 4 times


// 时钟周期，需要优化 4 8？
    auto col_sum_fragment = make_tensor<double>(Shape<_1,_8>{});

    col_sum_fragment(0) = (C_fragment(0,0) * C_fragment(0,0) + (C_fragment(0,1) * C_fragment(0,1) + (C_fragment(0,2) * C_fragment(0,2) + (C_fragment(0,3) * C_fragment(0,3)))));
    col_sum_fragment(1) = (C_fragment(1,0) * C_fragment(1,0) + (C_fragment(1,1) * C_fragment(1,1) + (C_fragment(1,2) * C_fragment(1,2) + (C_fragment(1,3) * C_fragment(1,3)))));
    col_sum_fragment(2) = (C_fragment(2,0) * C_fragment(2,0) + (C_fragment(2,1) * C_fragment(2,1) + (C_fragment(2,2) * C_fragment(2,2) + (C_fragment(2,3) * C_fragment(2,3)))));
    col_sum_fragment(3) = (C_fragment(3,0) * C_fragment(3,0) + (C_fragment(3,1) * C_fragment(3,1) + (C_fragment(3,2) * C_fragment(3,2) + (C_fragment(3,3) * C_fragment(3,3)))));
    col_sum_fragment(4) = (C_fragment(4,0) * C_fragment(4,0) + (C_fragment(4,1) * C_fragment(4,1) + (C_fragment(4,2) * C_fragment(4,2) + (C_fragment(4,3) * C_fragment(4,3)))));
    col_sum_fragment(5) = (C_fragment(5,0) * C_fragment(5,0) + (C_fragment(5,1) * C_fragment(5,1) + (C_fragment(5,2) * C_fragment(5,2) + (C_fragment(5,3) * C_fragment(5,3)))));
    col_sum_fragment(6) = (C_fragment(6,0) * C_fragment(6,0) + (C_fragment(6,1) * C_fragment(6,1) + (C_fragment(6,2) * C_fragment(6,2) + (C_fragment(6,3) * C_fragment(6,3)))));
    col_sum_fragment(7) = (C_fragment(7,0) * C_fragment(7,0) + (C_fragment(7,1) * C_fragment(7,1) + (C_fragment(7,2) * C_fragment(7,2) + (C_fragment(7,3) * C_fragment(7,3)))));

    axpby(1,col_sum_fragment,1, til_fragment);
    
    int reg_dist_to_bins[50] = {
         1,  1,  1,  2,  3,  4,  5,  6,  7,  8,
         9, 10, 11, 12, 13, 14, 14, 15, 15, 16,
        16, 17, 17, 18, 18, 19, 19, 20, 20, 21,
        21, 22, 22, 23, 23, 24, 24, 25, 25, 26,
        26, 27, 27, 28, 28, 29, 29, 30, 30, 31};

    // reg -> smem
    // 1024 double 
    int rec_num = (block_idx / lig_tile) * kTileM + thread_idx / 4;
    int lig_num = (block_idx % lig_tile) * kTileN + (thread_idx % 4) * 8;

    // double energy = 0.0;

    // if(thread0()){
    //     print_tensor(til_fragment);
    // }

    

    for(int i = 0; i< 8; i++){
        if(til_fragment(i) > 0 && til_fragment(i) <= 255){
            int d = sqrt(til_fragment(i)) * 2.0 - 1;
            
            int current_rec = rec_object[rec_num];
            int current_lig = lig_object[lig_num + i];
            
            int dfire_bin = reg_dist_to_bins[d] - 1;
            int array_idx = current_rec * 168 * 20 + current_lig * 20;
            double value = d_fastdfire[array_idx];

            r_ener(0) = r_ener(0) + value;
            
        }
    }
    // if(thread0()){
    //     print(r_ener(0));
    // }
    __syncthreads();

    cute::copy(r_ener, thr_C);
    // if(thread0()){
    //     print_tensor(gC);
    // }

    // d_energy_tmp[block_idz * num_glowworms * gridDim.x * block_size + block_idy * gridDim.x * block_size + block_idx * block_size + thread_idx] = energy;
    
    
    }

}







__forceinline__ __device__ 
void rotate(
    double * coord, double * rotate, 
    double * rotate_inverse, double * current_pos, double * current_pos2,
    int atom_num
)
{
    // rotation
                
    double weight = rotate[0];
    double pos_x = rotate[1];
    double pos_y = rotate[2];
    double pos_z = rotate[3];

    

    double rotate_norm2 = weight * weight + pos_x * pos_x + pos_y * pos_y + pos_z * pos_z;
    rotate_inverse[0] = rotate[0] / rotate_norm2;
    rotate_inverse[1] = - rotate[1] / rotate_norm2;
    rotate_inverse[2] = - rotate[2] / rotate_norm2;
    rotate_inverse[3] = - rotate[3] / rotate_norm2;
    
    #pragma unroll
    for(int i = 0; i<atom_num; i++){
        current_pos[0] = 0;
        // double w = 0 ;
        current_pos[1] = coord[i*3];
        current_pos[2] = coord[i*3+1];
        current_pos[3] = coord[i*3+2];
        // memcpy(current_pos+1, &coord[i*3], sizeof(double)*3);

        // qmul(current_pos2,rotate,current_pos);
        current_pos2[0] = (rotate[0] * current_pos[0] - rotate[1] * current_pos[1] - rotate[2] * current_pos[2] - rotate[3] * current_pos[3]);
        current_pos2[1] = (rotate[0] * current_pos[1] + rotate[1] * current_pos[0] + rotate[2] * current_pos[3] - rotate[3] * current_pos[2]);
        current_pos2[2] = (rotate[0] * current_pos[2] - rotate[1] * current_pos[3] + rotate[2] * current_pos[0] + rotate[3] * current_pos[1]);
        current_pos2[3] = (rotate[0] * current_pos[3] + rotate[1] * current_pos[2] - rotate[2] * current_pos[1] + rotate[3] * current_pos[0]);
        

        // qmul(current_pos, current_pos2, rotate_inverse);
        current_pos[0] = (current_pos2[0] * rotate_inverse[0] - current_pos2[1] * rotate_inverse[1] - current_pos2[2] * rotate_inverse[2] - current_pos2[3] * rotate_inverse[3]);
        current_pos[1] = (current_pos2[0] * rotate_inverse[1] + current_pos2[1] * rotate_inverse[0] + current_pos2[2] * rotate_inverse[3] - current_pos2[3] * rotate_inverse[2]);
        current_pos[2] = (current_pos2[0] * rotate_inverse[2] - current_pos2[1] * rotate_inverse[3] + current_pos2[2] * rotate_inverse[0] + current_pos2[3] * rotate_inverse[1]);
        current_pos[3] = (current_pos2[0] * rotate_inverse[3] + current_pos2[1] * rotate_inverse[2] - current_pos2[2] * rotate_inverse[1] + current_pos2[3] * rotate_inverse[0]);
        // std::cout<<current_pos[0]<<" "<<current_pos[1]<<" "<<current_pos[2]<<" "<<current_pos[3]<<std::endl;
        coord[i*3] = current_pos[1];
        coord[i*3+1] = current_pos[2];
        coord[i*3+2] = current_pos[3];

        // memcpy(&coord[i*3], &current_pos[1], sizeof(double)*3);
        
    }


}


__device__ __forceinline__
void compute_probability_moving_from_neighbors_gpu(
    double * probabilities, int * neighbors, double * luciferin, int nnei_len, double current_luciferin
){
    /*
    该方法目前存疑
    probabilities: 概率
    neighbors： 对应swarm ， 对应glowwormd的 邻居表
    luciferin： 当前swarm的luciferin
    nnei_len：当前 swarm 当前glowworm的邻居表长度
    current_luciferin：当前原子的luciferin
    */
    double total_sum = 0;
    // double * probabilities = new double [current_glowworm->nnei_len];
    for(int idx = 0; idx<nnei_len; idx++){
        int nei_id = neighbors[idx];
        // double current_luciferin = luciferin[idx];
        double neighbor_luciferin = luciferin[nei_id];
        double difference = neighbor_luciferin - current_luciferin;
        probabilities[idx] = difference;
        total_sum += difference;

    }
    for(int idx = 0; idx<nnei_len; idx++){
        probabilities[idx] /= total_sum;
    }
}


__global__ void prepare_receptor(
    double * d_receptor_pose, double * d_receptor_atom_coordinates, double * d_centers_pos, double * d_receptor_modes,
    int * d_receptor_mask,
    int swarms, int num_glowworms, int anm_lig, int anm_rec, int receptor_atoms
){
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    __shared__ double s_current_pose[1024];
    int pos_len = 7+anm_rec+anm_lig;
    double * pos_gloworm = &d_centers_pos[block_idz*num_glowworms*pos_len + block_idy*pos_len];
    double * current_receptor_pose = &d_receptor_pose[block_idz * num_glowworms * receptor_atoms*3 + block_idy * receptor_atoms*3];
    int n = block_size * block_idx + thread_idx;

    s_current_pose[thread_idx*3] = d_receptor_atom_coordinates[n*3];
    s_current_pose[thread_idx*3+1] = d_receptor_atom_coordinates[n*3+1];
    s_current_pose[thread_idx*3+2] = d_receptor_atom_coordinates[n*3+2];

    __syncthreads();
    if(n<receptor_atoms){
        for(int j = 0; j< DEFAULT_NMODES_REC; j++){
            double * rep_modes = &d_receptor_modes[j*receptor_atoms*3+n*3];
            double rec_extent = pos_gloworm[7+j];
            int mask = d_receptor_mask[n];
            s_current_pose[thread_idx*3] += rep_modes[0] * rec_extent * mask;
            s_current_pose[thread_idx*3+1] += rep_modes[1] * rec_extent * mask;
            s_current_pose[thread_idx*3+2] += rep_modes[2] * rec_extent * mask;
        }
        current_receptor_pose[n*3] = s_current_pose[thread_idx*3];
        current_receptor_pose[n*3+1] = s_current_pose[thread_idx*3+1];
        current_receptor_pose[n*3+2] = s_current_pose[thread_idx*3+2];

    }
    
}
__global__ void prepare_ligand(
    double * d_ligand_pose, double * d_ligand_atom_coordinates, double * d_current_pos, double * d_ligand_modes,
    int * d_ligand_mask,
    int swarms, int num_glowworms, int anm_lig, int anm_rec, int ligand_atoms
){
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    __shared__ double s_current_pose[1024];
    int pos_len = 7+anm_rec+anm_lig;
    double * pos_glowworm = &d_current_pos[block_idz*num_glowworms*pos_len + block_idy*pos_len];
    double * current_ligand_pose = &d_ligand_pose[block_idz * num_glowworms * ligand_atoms * 3 + block_idy * ligand_atoms * 3];
    int n = block_size * block_idx + thread_idx;
    s_current_pose[thread_idx*3] = d_ligand_atom_coordinates[n*3];
    s_current_pose[thread_idx*3+1] = d_ligand_atom_coordinates[n*3+1];
    s_current_pose[thread_idx*3+2] = d_ligand_atom_coordinates[n*3+2];
    __syncthreads();


    if(n<ligand_atoms){
        for(int j = 0; j< DEFAULT_NMODES_LIG; j++){
            double * lig_modes = &d_ligand_modes[j*ligand_atoms*3 + n*3];
            double lig_extent = pos_glowworm[7+DEFAULT_NMODES_REC+j];
            int mask = d_ligand_mask[n];
            s_current_pose[thread_idx*3] += lig_modes[0] * lig_extent * mask;
            s_current_pose[thread_idx*3+1] += lig_modes[1] * lig_extent * mask;
            s_current_pose[thread_idx *3+2] += lig_modes[2] * lig_extent * mask;
        }

        double * rotate = &pos_glowworm[3];
    
    
        double weight = rotate[0];
        double pos_x = rotate[1];
        double pos_y = rotate[2];
        double pos_z = rotate[3];

        

        double rotate_norm2 = weight * weight + pos_x * pos_x + pos_y * pos_y + pos_z * pos_z;
        double rotate_inverse_0 = rotate[0] / rotate_norm2;
        double rotate_inverse_1 = - rotate[1] / rotate_norm2;
        double rotate_inverse_2 = - rotate[2] / rotate_norm2;
        double rotate_inverse_3 = - rotate[3] / rotate_norm2;
        
        
        
        
        double current_pos_0 = 0;
        // double w = 0 ;
        double current_pos_1 = s_current_pose[thread_idx*3];
        double current_pos_2 = s_current_pose[thread_idx*3+1];
        double current_pos_3 = s_current_pose[thread_idx*3+2];
        // memcpy(current_pos+1, &coord[i*3], sizeof(double)*3);

        // qmul(current_pos2,rotate,current_pos);
        double  current_pos2_0 = (rotate[0] * current_pos_0 - rotate[1] * current_pos_1 - rotate[2] * current_pos_2 - rotate[3] * current_pos_3);
        double current_pos2_1 = (rotate[0] * current_pos_1 + rotate[1] * current_pos_0 + rotate[2] * current_pos_3 - rotate[3] * current_pos_2);
        double current_pos2_2 = (rotate[0] * current_pos_2 - rotate[1] * current_pos_3 + rotate[2] * current_pos_0 + rotate[3] * current_pos_1);
        double current_pos2_3 = (rotate[0] * current_pos_3 + rotate[1] * current_pos_2 - rotate[2] * current_pos_1 + rotate[3] * current_pos_0);
        

        // qmul(current_pos, current_pos2, rotate_inverse);
        current_pos_0 = (current_pos2_0 * rotate_inverse_0 - current_pos2_1 * rotate_inverse_1 - current_pos2_2 * rotate_inverse_2 - current_pos2_3 * rotate_inverse_3);
        current_pos_1 = (current_pos2_0 * rotate_inverse_1 + current_pos2_1 * rotate_inverse_0 + current_pos2_2 * rotate_inverse_3 - current_pos2_3 * rotate_inverse_2);
        current_pos_2 = (current_pos2_0 * rotate_inverse_2 - current_pos2_1 * rotate_inverse_3 + current_pos2_2 * rotate_inverse_0 + current_pos2_3 * rotate_inverse_1);
        current_pos_3 = (current_pos2_0 * rotate_inverse_3 + current_pos2_1 * rotate_inverse_2 - current_pos2_2 * rotate_inverse_1 + current_pos2_3 * rotate_inverse_0);
        // std::cout<<current_pos_0<<" "<<current_pos_1<<" "<<current_pos_2<<" "<<current_pos_3<<std::endl;
        s_current_pose[thread_idx*3] = current_pos_1;
        s_current_pose[thread_idx*3+1] = current_pos_2;
        s_current_pose[thread_idx*3+2] = current_pos_3;

        s_current_pose[thread_idx*3] += pos_glowworm[0];
        s_current_pose[thread_idx*3+1] +=  pos_glowworm[1];
        s_current_pose[thread_idx*3+2] +=  pos_glowworm[2];

        current_ligand_pose[n*3] = s_current_pose[thread_idx*3];
        current_ligand_pose[n*3+1] = s_current_pose[thread_idx*3+1];
        current_ligand_pose[n*3+2] = s_current_pose[thread_idx*3+2];

    }
}

__global__ void prepare_receptor_pose(
    double * d_centers_pos, double * d_receptor_pose, 
    double * d_receptor_atom_coordinates, 
    double * d_receptor_modes, 
    int * d_receptor_mask, 
    int * d_moved_base, int * d_step_base,
    int swarms, int num_glowworms, int anm_lig, int anm_rec,
    int receptor_atoms
){
    /*
    rotate 内存创建
    */
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    __shared__ int s_mem[8192];
    double * s_current_pose = (double *)s_mem;
    int * s_mask = s_mem+2048;
    // __shared__ double s_current_pose[1024];
    int pos_len = 7+anm_rec+anm_lig;
    double * pos_gloworm = &d_centers_pos[block_idz*num_glowworms*pos_len + block_idy*pos_len];
    double * current_receptor_pose = &d_receptor_pose[block_idz * num_glowworms * receptor_atoms*3 + block_idy * receptor_atoms*3];
    int n = block_size * block_idx + thread_idx;
    // double * s_pos = s_mem;
    // double * s_current_pose = s_mem;

    s_current_pose[thread_idx*3] = d_receptor_atom_coordinates[n*3];
    s_current_pose[thread_idx*3+1] = d_receptor_atom_coordinates[n*3+1];
    s_current_pose[thread_idx*3+2] = d_receptor_atom_coordinates[n*3+2];
    s_mask[thread_idx] = d_receptor_mask[n];
    __syncthreads();

    double center_pos [27];
    for(int i = 0; i<27; i++){
        center_pos[i] = pos_gloworm[i];
    }
    int moved = d_moved_base[block_idz*num_glowworms + block_idy];
    int steped = d_step_base[block_idz*num_glowworms + block_idy];
    // printf("%d\n",moved);
    if (n<receptor_atoms && (moved || steped == 0)){
        // for(int jj = 0; jj< 3;jj++){
        //     current_receptor_pose[n*3 +jj] = d_receptor_atom_coordinates[n*3+jj];
        // }
        for(int j = 0; j<DEFAULT_NMODES_REC; j++){
            double * rep_modes = &d_receptor_modes[j*receptor_atoms*3+n*3];
            double rec_instant = center_pos[7+j]; 
            int mask = s_mask[thread_idx];
            s_current_pose[thread_idx*3] += rep_modes[0] * rec_instant * mask;
            s_current_pose[thread_idx*3+1] += rep_modes[1] * rec_instant * mask;
            s_current_pose[thread_idx*3+2] += rep_modes[2] * rec_instant * mask;
        }
        // if(block_idz==3 && block_idy==3 && block_idx==0 && thread_idx==0){
        //     printf("%f %f %f \n", current_receptor_pose[n*3],current_receptor_pose[n*3+1],current_receptor_pose[n*3+2]);
        // }
        current_receptor_pose[n*3] = s_current_pose[thread_idx*3];
        current_receptor_pose[n*3+1] = s_current_pose[thread_idx*3+1];
        current_receptor_pose[n*3+2] = s_current_pose[thread_idx*3+2];
    }

}

__global__ void prepare_lignad_pose(
    double * d_centers_pos,double * d_ligand_pose, double * d_ligand_reference_pose,
    double * d_ligand_atom_coordinates,  
    double * d_current_ligand_reference_pose, 
    double * d_ligand_modes,
    int * d_ligand_mask,
    int * d_moved_base, int * d_step_base,
    int swarms, int num_glowworms, int anm_lig, int anm_rec,
    int ligand_atoms
){
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    double * pos_gloworm = &d_centers_pos[block_idz*num_glowworms*(7+anm_rec+anm_lig) + block_idy*(7+anm_rec+anm_lig)];
    // share 
    double * current_ligand_pose = &d_ligand_pose[block_idz * num_glowworms * ligand_atoms*3 + block_idy * ligand_atoms*3];
    double * current_ligand_reference_pose = &d_ligand_reference_pose[block_idz * num_glowworms * 3 + block_idy * 3];
    __shared__ int s_mem[8192];
    double * s_current_pose = (double *)s_mem;
    int * s_mask = s_mem+2048;
    
    // __shared__ double s_current_pose[1024];

    int moved = d_moved_base[block_idz*num_glowworms + block_idy];
    int steped = d_step_base[block_idz*num_glowworms + block_idy];
    int n = block_size * block_idx + thread_idx;

    s_current_pose[thread_idx*3] = d_ligand_atom_coordinates[n*3];
    s_current_pose[thread_idx*3+1] = d_ligand_atom_coordinates[n*3+1];
    s_current_pose[thread_idx*3+2] = d_ligand_atom_coordinates[n*3+2];

    s_mask[thread_idx] = d_ligand_mask[n];
    __syncthreads();

    double center_pos [27];
    for(int i = 0; i<27; i++){
        center_pos[i] = pos_gloworm[i];
    }
    if(n < ligand_atoms && (moved || steped == 0)){
        // for(int jj = 0; jj<3;jj++){
        //     current_ligand_pose[n*3+jj] = d_ligand_atom_coordinates[n*3+jj];
        // }
        #pragma unroll
        for(int j = 0;j<DEFAULT_NMODES_LIG; j++){

            double * rep_modes = &d_ligand_modes[j*ligand_atoms*3+n*3]; //
            double rec_instant = center_pos[7+DEFAULT_NMODES_REC+j];
            int mask  = s_mask[thread_idx];
            // if(mask == 1){
            s_current_pose[thread_idx*3] += rep_modes[0] * rec_instant * mask;
            s_current_pose[thread_idx*3+1] += rep_modes[1] * rec_instant * mask;
            s_current_pose[thread_idx*3+2] += rep_modes[2] * rec_instant * mask;
                // }
            

        }

        double * rotate = &center_pos[3];
    
    
        double weight = rotate[0];
        double pos_x = rotate[1];
        double pos_y = rotate[2];
        double pos_z = rotate[3];

        

        double rotate_norm2 = weight * weight + pos_x * pos_x + pos_y * pos_y + pos_z * pos_z;
        double rotate_inverse_0 = rotate[0] / rotate_norm2;
        double rotate_inverse_1 = - rotate[1] / rotate_norm2;
        double rotate_inverse_2 = - rotate[2] / rotate_norm2;
        double rotate_inverse_3 = - rotate[3] / rotate_norm2;
        
        
        
        
        double current_pos_0 = 0;
        // double w = 0 ;
        double current_pos_1 = s_current_pose[thread_idx*3];
        double current_pos_2 = s_current_pose[thread_idx*3+1];
        double current_pos_3 = s_current_pose[thread_idx*3+2];
        // memcpy(current_pos+1, &coord[i*3], sizeof(double)*3);

        // qmul(current_pos2,rotate,current_pos);
        double  current_pos2_0 = (rotate[0] * current_pos_0 - rotate[1] * current_pos_1 - rotate[2] * current_pos_2 - rotate[3] * current_pos_3);
        double current_pos2_1 = (rotate[0] * current_pos_1 + rotate[1] * current_pos_0 + rotate[2] * current_pos_3 - rotate[3] * current_pos_2);
        double current_pos2_2 = (rotate[0] * current_pos_2 - rotate[1] * current_pos_3 + rotate[2] * current_pos_0 + rotate[3] * current_pos_1);
        double current_pos2_3 = (rotate[0] * current_pos_3 + rotate[1] * current_pos_2 - rotate[2] * current_pos_1 + rotate[3] * current_pos_0);
        

        // qmul(current_pos, current_pos2, rotate_inverse);
        current_pos_0 = (current_pos2_0 * rotate_inverse_0 - current_pos2_1 * rotate_inverse_1 - current_pos2_2 * rotate_inverse_2 - current_pos2_3 * rotate_inverse_3);
        current_pos_1 = (current_pos2_0 * rotate_inverse_1 + current_pos2_1 * rotate_inverse_0 + current_pos2_2 * rotate_inverse_3 - current_pos2_3 * rotate_inverse_2);
        current_pos_2 = (current_pos2_0 * rotate_inverse_2 - current_pos2_1 * rotate_inverse_3 + current_pos2_2 * rotate_inverse_0 + current_pos2_3 * rotate_inverse_1);
        current_pos_3 = (current_pos2_0 * rotate_inverse_3 + current_pos2_1 * rotate_inverse_2 - current_pos2_2 * rotate_inverse_1 + current_pos2_3 * rotate_inverse_0);
        // std::cout<<current_pos_0<<" "<<current_pos_1<<" "<<current_pos_2<<" "<<current_pos_3<<std::endl;
        s_current_pose[thread_idx*3] = current_pos_1;
        s_current_pose[thread_idx*3+1] = current_pos_2;
        s_current_pose[thread_idx*3+2] = current_pos_3;

        s_current_pose[thread_idx*3] += pos_gloworm[0];
        s_current_pose[thread_idx*3+1] +=  pos_gloworm[1];
        s_current_pose[thread_idx*3+2] +=  pos_gloworm[2];

        current_ligand_pose[n*3] = s_current_pose[thread_idx*3];
        current_ligand_pose[n*3+1] = s_current_pose[thread_idx*3+1];
        current_ligand_pose[n*3+2] = s_current_pose[thread_idx*3+2];

        // reference
        //  blockz 和 blocky
        // if(block_idz==3 && block_idy==3 && block_idx==0 && thread_idx==0){
        //     printf("%f %f %f \n", current_ligand_pose[n*3],current_ligand_pose[n*3+1],current_ligand_pose[n*3+2]);
        // }
        if(thread_idx == 0 && block_idx==0){
            for(int i=0;i<3;i++){
                current_ligand_reference_pose[i] = d_current_ligand_reference_pose[i];
            }
            // rotate
            double current_pos_0 = 0;
            // double w = 0 ;
            double current_pos_1 = current_ligand_reference_pose[0];
            double current_pos_2 = current_ligand_reference_pose[1];
            double current_pos_3 = current_ligand_reference_pose[2];
            // memcpy(current_pos+1, &coord[i*3], sizeof(double)*3);

            // qmul(current_pos2,rotate,current_pos);
            double  current_pos2_0 = (rotate[0] * current_pos_0 - rotate[1] * current_pos_1 - rotate[2] * current_pos_2 - rotate[3] * current_pos_3);
            double current_pos2_1 = (rotate[0] * current_pos_1 + rotate[1] * current_pos_0 + rotate[2] * current_pos_3 - rotate[3] * current_pos_2);
            double current_pos2_2 = (rotate[0] * current_pos_2 - rotate[1] * current_pos_3 + rotate[2] * current_pos_0 + rotate[3] * current_pos_1);
            double current_pos2_3 = (rotate[0] * current_pos_3 + rotate[1] * current_pos_2 - rotate[2] * current_pos_1 + rotate[3] * current_pos_0);
            

            // qmul(current_pos, current_pos2, rotate_inverse);
            current_pos_0 = (current_pos2_0 * rotate_inverse_0 - current_pos2_1 * rotate_inverse_1 - current_pos2_2 * rotate_inverse_2 - current_pos2_3 * rotate_inverse_3);
            current_pos_1 = (current_pos2_0 * rotate_inverse_1 + current_pos2_1 * rotate_inverse_0 + current_pos2_2 * rotate_inverse_3 - current_pos2_3 * rotate_inverse_2);
            current_pos_2 = (current_pos2_0 * rotate_inverse_2 - current_pos2_1 * rotate_inverse_3 + current_pos2_2 * rotate_inverse_0 + current_pos2_3 * rotate_inverse_1);
            current_pos_3 = (current_pos2_0 * rotate_inverse_3 + current_pos2_1 * rotate_inverse_2 - current_pos2_2 * rotate_inverse_1 + current_pos2_3 * rotate_inverse_0);
            // std::cout<<current_pos_0<<" "<<current_pos_1<<" "<<current_pos_2<<" "<<current_pos_3<<std::endl;
            current_ligand_reference_pose[0] = current_pos_1;
            current_ligand_reference_pose[1] = current_pos_2;
            current_ligand_reference_pose[2] = current_pos_3;

            current_ligand_reference_pose[0] += pos_gloworm[0];
            current_ligand_reference_pose[1] += pos_gloworm[1];
            current_ligand_reference_pose[2] += pos_gloworm[2];

            
        }
        // if(block_idz==3 && block_idy==3 && block_idx==0 && thread_idx==0){
        //     printf("%f %f %f \n", current_ligand_reference_pose[0],current_ligand_reference_pose[1],current_ligand_reference_pose[2]);
        // }
            
            
            
    }

}


__global__ void calculate_dfire(
    double * d_receptor_pose, double * d_ligand_pose, 
    double * d_scoring_base, double * d_luciferin_base, double * d_rho_base, double * d_gamma_base, 
    double * energy_tmp,
    int * d_moved_base, int * d_step_base,
    double * fastdfire, int * dfire_objects_rec, int * dfire_objects_lig, unsigned int * d_dist_to_bins,
    int swarms, int num_glowworms, int anm_lig, int anm_rec,
    int receptor_atoms, int ligand_atoms
){
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    // if(block_idz==3 && block_idy==3 && block_idx==0 && thread_idx==0){
    //         printf("test \n");
    // }
    int pos_len = 7+anm_rec+anm_lig;
    __shared__ int s_mem[8192];
    
    // __shared__ double s_mem[512];
    // double * s_pos = s_mem;
    double * s_ener = (double*)s_mem;
    double * s_current_receptor_pose = (double *)(s_mem+1024);
    int * s_dfire_objects_rec = (int * )(s_mem+1024+2048);
    
    
    // share 
    double * current_ligand_pose = &d_ligand_pose[block_idz * num_glowworms * ligand_atoms*3 + block_idy * ligand_atoms*3];
    // double * current_ligand_reference_pose = &d_ligand_reference_pose[block_idz * num_glowworms * 3 + block_idy * 3];
    double * current_receptor_pose = &d_receptor_pose[block_idz * num_glowworms * receptor_atoms*3 + block_idy * receptor_atoms*3];

    int moved = d_moved_base[block_idz*num_glowworms + block_idy];
    int steped = d_step_base[block_idz*num_glowworms + block_idy];

    double rho =  d_rho_base[block_idz*num_glowworms+block_idy];
    double luciferins = d_luciferin_base[block_idz*num_glowworms+block_idy];
    double gamma = d_gamma_base[block_idz*num_glowworms+block_idy];
    double energy = d_scoring_base[block_idz*num_glowworms+block_idy];

    int n = block_size * block_idx + thread_idx;
    s_current_receptor_pose[thread_idx * 3] = current_receptor_pose[n*3+0];
    s_current_receptor_pose[thread_idx * 3 + 1] = current_receptor_pose[n*3+1];
    s_current_receptor_pose[thread_idx * 3 + 2] = current_receptor_pose[n*3+2];
    s_dfire_objects_rec[thread_idx] = dfire_objects_rec[n];
    // s_ener[thread_idx] = 0;
    __syncthreads();
    
    if((moved || steped == 0) ){
        energy=0.0;

        // double energy = energy_array[n];
        for (int j = 0; j < ligand_atoms; j++) {
            double dist0 = s_current_receptor_pose[thread_idx * 3] - current_ligand_pose[j*3+0];
            double dist1 = s_current_receptor_pose[thread_idx * 3 + 1] - current_ligand_pose[j*3+1];
            double dist2 = s_current_receptor_pose[thread_idx * 3 + 2] - current_ligand_pose[j*3+2];

            double dist = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;
            // if(n >= receptor_atoms) {dist=0.0;}
            
            if (dist <= 225.) {

                int d = (sqrt(dist)*2.0 - 1.0);
                int atoma = s_dfire_objects_rec[thread_idx];
                int atomb = dfire_objects_lig[j];
                int dfire_bin = d_dist_to_bins[d] - 1;
                unsigned int array_ = atoma*168*20 + atomb*20 + dfire_bin;
                double value = fastdfire[array_];
                energy += value;
                

            }
        }
        // reduce
        // 当前receptor的enrngy
        

        s_ener[thread_idx] = (n<receptor_atoms) ? energy : 0;
        __syncthreads();

        for(int offset = block_size >> 1; offset >= 32; offset >>=1){
            if(thread_idx < offset){
                s_ener[thread_idx] += s_ener[thread_idx+offset];
            }
            __syncthreads();
        }
        double y = s_ener[thread_idx];
        for(int offset = 16; offset > 0; offset>>=1){
            y+=__shfl_down_sync(FULL_MASK,y,offset);
        }

        
        

        if(thread_idx==0){
            energy_tmp[block_idz*num_glowworms*gridDim.x + block_idy*gridDim.x + block_idx] = y;
        }
    }
}

__global__ void cal_score(
    double * d_scoring_base, double * d_luciferin_base, double * d_rho_base, double * d_gamma_base, 
    double * energy_tmp,
    int * d_moved_base, int * d_step_base,
    int swarms, int num_glowworms, int anm_lig, int anm_rec,
    int receptor_atoms, int ligand_atoms, int len
){
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    // const int block_idz = blockIdx.z;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    __shared__ double  s_ener[512];

    double rho =  d_rho_base[block_idy*num_glowworms+block_idx];
    double luciferins = d_luciferin_base[block_idy*num_glowworms+block_idx];
    double gamma = d_gamma_base[block_idy*num_glowworms+block_idx];
    // double energy = d_scoring_base[block_idy*num_glowworms+block_idx];

    int moved = d_moved_base[block_idy*num_glowworms + block_idx];
    int steped = d_step_base[block_idy*num_glowworms + block_idx];

    // double * current_energy = &energy_tmp[block_idy*num_glowworms*block_size+block_idx*block_size];
    int N = swarms*num_glowworms*len;
    int n = block_idy*num_glowworms*len+block_idx*len+thread_idx;
    __syncthreads();

    // if(block_idy==3 && block_idx==3){

    //     printf("%f \n", energy_tmp[n]);
    // }
    if((moved || steped == 0)){
        s_ener[thread_idx] = (n<N) ? energy_tmp[n]: 0;
        __syncthreads();

        for(int offset = block_size >> 1; offset >= 32; offset >>=1){
            if(thread_idx < offset){
                s_ener[thread_idx] += s_ener[thread_idx+offset];
            }
            __syncthreads();
        }
        double y = s_ener[thread_idx];
        for(int offset = 16; offset > 0; offset>>=1){
            y+=__shfl_down_sync(FULL_MASK,y,offset);
        }

        if(thread_idx==0){
            d_scoring_base[block_idy*num_glowworms+block_idx] = ((y)*0.0157 - 4.7)*-1;
        }
        if(block_idy == 3 && block_idx==3 && thread_idx==0){
            printf("energy %f \n", d_scoring_base[block_idy*num_glowworms+block_idx]);
        }


    }
    if(thread_idx == 0){
        d_luciferin_base[block_idy*num_glowworms+block_idx] = (1.0 - rho) * d_luciferin_base[block_idy*num_glowworms+block_idx] + gamma * d_scoring_base[block_idy*num_glowworms+block_idx];
    }


}

__global__ void cal_move_neighbors(
    double * d_select_position_base, int * d_neighbors_base, double * d_vision_range_base, int * d_select_base, int * d_nnei_len_base,
    double * d_luciferin_base, double * d_probabilities, double * d_prob_array, double * d_centers_pos, double * d_ligand_reference_pose,
    int swarms, int num_glowworms, int anm_lig, int anm_rec,
    int ligand_atoms,int step
){
    int block_idx = blockIdx.x;
    int thread_idx = threadIdx.x;

    double * current_reference = &d_ligand_reference_pose[block_idx*num_glowworms*3+thread_idx*3];
    int * neighbors = &d_neighbors_base[block_idx*num_glowworms*num_glowworms + thread_idx*num_glowworms];
    double vision_range = d_vision_range_base[block_idx*num_glowworms+thread_idx];
    int nnei_len = 0;
    double * move_postion = &d_select_position_base[block_idx * num_glowworms * (7+anm_rec+anm_lig) + thread_idx * (7+anm_rec+anm_lig)];
    double current_luciferin = d_luciferin_base[block_idx*num_glowworms + thread_idx];
    double * probabilities = &d_probabilities[block_idx*num_glowworms*num_glowworms+ thread_idx*num_glowworms];
    double squared_vision_range = vision_range * vision_range;
    double prob = d_prob_array[block_idx*STEPS*num_glowworms + step * num_glowworms + thread_idx];
    double * current_pos = &d_centers_pos[block_idx*num_glowworms*(7+anm_rec+anm_lig)];

    // int select_index = d_select_index[block_idx];
    // int * select = d_select[block_idx*num_glowworms];

    int current_nnei_len = 0;
    // step 7
    if(block_idx==0 && thread_idx==95){
        printf("improtant nl:%.10f\n",d_luciferin_base[block_idx*num_glowworms + thread_idx]); // -53.655593
        printf("%f %f %f \n",current_reference[0],current_reference[1],current_reference[2]); // 1.606625 24.444249 -7.706393 
        printf("%f \n", d_vision_range_base[block_idx*num_glowworms+thread_idx]);  //2.2
        
    }
    // for(int ii = 0; ii< num_glowworms; ii++){
    //     neighbors[ii] = 0;
    // }
    for(int n = 0; n<num_glowworms; n++){
        double neighbor_luciferin = d_luciferin_base[block_idx*num_glowworms + n];
        
        if(n!=thread_idx && current_luciferin < neighbor_luciferin){
            
            double * neighbor_reference = &d_ligand_reference_pose[block_idx*num_glowworms*3 + n*3];
            double distance = 0;
            for(int dis = 0; dis < 3; dis++){
                distance += ((current_reference[dis] - neighbor_reference[dis])*(current_reference[dis] - neighbor_reference[dis]));
            }
            // if(block_idx==0 && thread_idx==56 && n==19){
                   
            //         printf("%f \n",distance);
            // }
            if (distance < squared_vision_range){
                // neighbors 
                neighbors[current_nnei_len++] = n; // param
            }

        }

    }
    
    if(block_idx==0 && thread_idx==95){
        printf("nnei_len %d\n",current_nnei_len);
        for(int ii = 0; ii< current_nnei_len; ii++){
            printf("%d ",neighbors[ii]);
        }
        printf("\n");
    }
    d_nnei_len_base[block_idx*num_glowworms+thread_idx] = current_nnei_len;
    // if(thread_idx==1 && block_idx == 0){
    //     printf("%d \n", current_nnei_len);
    //     // printf("%f %f %f \n", current_ligand_pose[0],current_ligand_pose[1],current_ligand_pose[2]);
    //     // printf("%f %f %f \n", current_receptor_pose[0],current_receptor_pose[1],current_receptor_pose[2]);
    
    // }

    compute_probability_moving_from_neighbors_gpu(probabilities, neighbors, &d_luciferin_base[block_idx*num_glowworms], current_nnei_len,  current_luciferin);
    //当前进程所选的index
    // 重要，计算sum_probabilities 的前缀加和，根据前缀加和确定
    
    if(current_nnei_len == 0){
        d_select_base[block_idx*num_glowworms+thread_idx] = thread_idx;
    }else{
        double sum_probabilities = 0;
        int idx = 0;
        while(sum_probabilities < prob){
            sum_probabilities += probabilities[idx];
            idx++;
        }
        d_select_base[block_idx*num_glowworms+thread_idx] = neighbors[idx-1];
        // if(block_idx==0 && thread_idx==56){
        //     printf("idx %d\n",neighbors[idx-1]);
        //     // printf("move_postion:%f %f %f \n",current_pos[thread_idx*(7+anm_rec+anm_lig)],current_pos[thread_idx*(7+anm_rec+anm_lig)+1],current_pos[thread_idx*(7+anm_rec+anm_lig)+2]);
            
        // }
    }
    int nnei_index = d_select_base[block_idx*num_glowworms+thread_idx];

    if(block_idx==0 && thread_idx==95){
        printf("nnei_index %d\n",nnei_index);
        printf("prob %f \n",prob);
        // printf("move_postion:%f %f %f \n",current_pos[thread_idx*(7+anm_rec+anm_lig)],current_pos[thread_idx*(7+anm_rec+anm_lig)+1],current_pos[thread_idx*(7+anm_rec+anm_lig)+2]);
        
    }

    for(int ii = 0; ii<(7+anm_rec+anm_lig); ii++){
        move_postion[ii] = current_pos[nnei_index*(7+anm_rec+anm_lig) + ii];
    }

    // if(thread_idx==56 && block_idx ==0){
    //     printf("move_postion1111:%f %f %f \n",move_postion[0],move_postion[1],move_postion[2]);
    //     printf("move_translation2:%f %f %f \n",current_pos[nnei_index*(7+anm_rec+anm_lig) + 0],current_pos[nnei_index*(7+anm_rec+anm_lig) + 1],current_pos[nnei_index*(7+anm_rec+anm_lig) + 2]);
    
    // }

}

__device__ __forceinline__
void slerp_gpu(double * self, double * other, double rotation_step){
    // calculate inter polation
    double self_norm2 = 0;
    double other_norm2 = 0;

    for(int i = 0; i<4;i++){
        self_norm2 += (self[i] * self[i]);
        other_norm2 += (other[i] * other[i]);
    }
    self_norm2 = sqrt(self_norm2);
    other_norm2 = sqrt(other_norm2);
    for(int i = 0; i<4;i++){
        self[i] /= self_norm2;
        other[i] /= other_norm2;
    }
    // calc dot
    double q_dot = 0;
    for(int i = 0; i<4;i++){
        q_dot += self[i] * other[i];
    }
    if(q_dot < 0){
        q_dot = q_dot * -1;
        for(int i = 0; i< 4; i++){
            self[i] = -self[i];
        }
    }

    if(q_dot>0.9995){
        for(int i = 0; i < 4; i++){
            self[i] = self[i] + rotation_step * (other[i] - self[i]);
        }
        double result_norm = 0;
        for(int i = 0; i< 4; i++){
            result_norm += (self[i] * self[i]);
        }
        result_norm = sqrt(result_norm);
        for(int i = 0; i<4;i++){
            self[i] /= result_norm;
        }
    }else{
        q_dot = (q_dot < 1) ? q_dot : 1;
        q_dot = (q_dot > -1) ? q_dot : -1;
        double omega = acos(q_dot);
        double so = sin(omega);
        double tmp0 = (sin((1.0-rotation_step)*omega) / so);
        double tmp1 = (sin(rotation_step*omega)/so);
        for(int i = 0; i< 4; i++){
            self[i] = tmp0 * self[i] + tmp1 * other[i];
        }
    }

}

__device__ __forceinline__
void move_extent(double * self, double * other, double * delta_x ,int num_ext,double step_nmodes){
    // double * delta_x = new double [num_ext];
    double n = 0;
    for(int i = 0; i< num_ext; i++){
        delta_x[i] = other[i] - self[i];
        n += delta_x[i] * delta_x[i];
    }   
    
    n = sqrt(n);
    if(n>=1e-8){
        for(int i = 0; i< num_ext; i++){
            delta_x[i] *= step_nmodes/n;
            self[i] += delta_x[i];
        }
    }
    // delete [] delta_x;
}

__global__ void move_position(
    double * d_vision_range_base, double * d_centers_pos, double * d_select_position_base, 
    int * d_id_base, int *d_selece_base, double * d_delta_base, double * d_rec_base, double * d_lig_base, 
    double * d_beta_base, int  * d_max_neighbors_base,
    double * d_max_vision_range_base, int * d_nnei_len_base,
    int * d_moved_base, int swarm, int num_glowworms,int anm_lig, int anm_rec,
    int ligand_atoms,int step
){
    int thread_idx = threadIdx.x;
    int block_idx = blockIdx.x;
    double * current_postion = &d_centers_pos[block_idx*num_glowworms*(7+anm_rec+anm_lig)+thread_idx*(7+anm_rec+anm_lig)];
    double * move_postion = &d_select_position_base[block_idx*num_glowworms*(7+anm_rec+anm_lig)+thread_idx*(7+anm_rec+anm_lig)];
    int id = d_id_base[block_idx*num_glowworms+thread_idx];
    // TODO: 冗余
    int nei_idx = d_selece_base[block_idx*num_glowworms+thread_idx];
    int nei_id = d_id_base[block_idx*num_glowworms+nei_idx];
    double *delta = &d_delta_base[block_idx*num_glowworms*3+thread_idx*3];
    double * rec_ext = &d_rec_base[block_idx*num_glowworms*anm_rec+thread_idx*anm_rec];
    double *lig_ext = &d_lig_base[block_idx*num_glowworms*anm_lig+thread_idx*anm_lig];
    d_moved_base[block_idx*num_glowworms+thread_idx] = id != nei_id;
    // if(thread_idx==62 && block_idx ==0){
    //     printf("%d\n",id);
    //     printf("%d\n",nei_id);
    // }
    if(id != nei_id){
        double * move_tranlation = &move_postion[0];
        double * current_translation = &current_postion[0];
        double * current_rotation = &current_postion[3];
        double * move_rotation = &move_postion[3];

        double * current_rec_extent = &current_postion[7];
        double * move_rec_extent = &move_postion[7];

        double * current_lig_extent = &current_postion[7+anm_rec];
        double * move_lig_extent = &move_postion[7+anm_rec];
        
        double n = 0;
        // if(thread_idx==62 && block_idx ==0){
        //     printf("move_translation:%f %f %f \n",move_tranlation[0],move_tranlation[1],move_tranlation[2]);
        //     printf("move_translation2:%f %f %f \n",current_translation[0],current_translation[1],current_translation[2]);
        
        // }
        // 问题出在这里
        if(thread_idx==95 && block_idx ==0){
            printf("current_translation:%f %f %f \n",current_translation[0],current_translation[1],current_translation[2]);
            printf("move:%f %f %f \n",move_tranlation[0],move_tranlation[1],move_tranlation[2]);
        
        }
        for(int d = 0; d<3; d++){
            delta[d] = move_tranlation[d] - current_translation[d];
            n+=delta[d] * delta[d];
        }
        n = sqrt(n);
        // if(thread_idx==62 && block_idx ==0){
        //     printf("n: %f", n);

        // }
        if(n>=1e-8){
            for(int d = 0; d<3; d++){
                delta[d]*=(0.5 / n);
                current_translation[d] += delta[d];
            }
        }
        
        slerp_gpu(current_rotation,move_rotation, 0.5);

        move_extent(current_rec_extent,move_rec_extent,rec_ext,anm_rec,0.5);
        move_extent(current_lig_extent,move_lig_extent,lig_ext,anm_lig,0.5);
        // if(thread_idx==56 && block_idx ==0){
        //     printf("current_translation:%f %f %f \n",current_translation[0],current_translation[1],current_translation[2]);
        //     printf("current_rotation:%f %f %f %f \n",current_rotation[0],current_rotation[1],current_rotation[2], current_rotation[3]);
        //     printf("rec_ext:%f %f %f %f \n",current_rec_extent[0],current_rec_extent[1],current_rec_extent[2], current_rec_extent[3]);
        //     printf("lig_ext:%f %f %f %f \n",current_lig_extent[0],current_lig_extent[1],current_lig_extent[2], current_lig_extent[3]);
        //     // printf("current_translation:%f %f %f \n",current_translation[0],current_translation[1],current_translation[2]);
        
        // }
    }
    d_vision_range_base[block_idx*num_glowworms+thread_idx] = d_vision_range_base[block_idx*num_glowworms+thread_idx] + d_beta_base[block_idx*num_glowworms+thread_idx] * (d_max_neighbors_base[block_idx*num_glowworms+thread_idx] - d_nnei_len_base[block_idx*num_glowworms+thread_idx]);
    if(d_vision_range_base[block_idx*num_glowworms+thread_idx]<0.0){d_vision_range_base[block_idx*num_glowworms+thread_idx] = 0;}
    if(d_vision_range_base[block_idx*num_glowworms+thread_idx] > d_max_vision_range_base[block_idx*num_glowworms+thread_idx]){d_vision_range_base[block_idx*num_glowworms+thread_idx]=d_max_vision_range_base[block_idx*num_glowworms+thread_idx];}
    if(thread_idx==56 && block_idx ==0){
        printf(" viusion range%f\n",d_vision_range_base[block_idx*num_glowworms+thread_idx]);
        // printf("%d\n",nei_id);
    }

}


template<typename Key,
    int         BLOCK_THREADS,
    int         ITEMS_PER_THREAD>
__launch_bounds__(BLOCK_THREADS)
__global__ void BlockSortKernel(Key * d_in, Key * d_out){
    enum { TILE_SIZE = BLOCK_THREADS * ITEMS_PER_THREAD };
    // Specialize BlockLoad type for our thread block (uses warp-striped loads for coalescing, then transposes in shared memory to a blocked arrangement)
    typedef cub::BlockLoad<Key, BLOCK_THREADS, ITEMS_PER_THREAD, cub::BLOCK_LOAD_WARP_TRANSPOSE> BlockLoadT;
    // Specialize BlockRadixSort type for our thread block
    typedef cub::BlockRadixSort<Key, BLOCK_THREADS, ITEMS_PER_THREAD> BlockRadixSortT;
    // Shared memory
    __shared__ union TempStorage
    {
        typename BlockLoadT::TempStorage        load;
        typename BlockRadixSortT::TempStorage   sort;
    } temp_storage;
    // Per-thread tile items
    Key items[ITEMS_PER_THREAD];
    // Our current block's offset
    int block_offset = blockIdx.x * TILE_SIZE;
    // Load items into a blocked arrangement
    BlockLoadT(temp_storage.load).Load(d_in + block_offset, items);
    // Barrier for smem reuse
    __syncthreads();
    // Sort keys
    BlockRadixSortT(temp_storage.sort).SortDescendingBlockedToStriped(items);
    // Store output in striped fashion
    cub::StoreDirectStriped<BLOCK_THREADS>(threadIdx.x, d_out + block_offset, items);
}

__global__ void prepare_pair(int64_t * d_sort_pair, int* id, double * d_scoring_base, int num_glowworms){
    const int block_idx = blockIdx.x;
    const int thread_idx = threadIdx.x;
    __shared__ int smem[9216];
    double * s_score = (double *)smem;
    int * s_id = (int *)(smem + 512 * 2);
    int64_t * s_sort_pair = (int64_t*)(smem + 512 * 2 + 512 );
    s_id[thread_idx] = id[block_idx * num_glowworms + thread_idx];
    s_score[thread_idx] = d_scoring_base[block_idx * num_glowworms + thread_idx];
    // mem.s_id[thread_idx] = id[block_idx * num_glowworms + thread_idx];
    // mem.s_score[thread_idx] = d_scoring_base[block_idx * num_glowworms + thread_idx];
    __syncthreads();
    int cur_id = s_id[thread_idx];
    double cur_score = s_score[thread_idx];

    s_sort_pair[thread_idx] = (int64_t)(cur_score * ((int64_t)1<<50)) / (1<<12) * (1<<12) + cur_id;
    d_sort_pair[block_idx * num_glowworms + thread_idx] = s_sort_pair[thread_idx];
}

bool compare2(int64_t g1, int64_t g2){
    return g1>g2;
}

__global__ void perform_rmsd_cal(
    double * d_rmsd_tmp, int * d_backbone_tmp,
    double * d_receptor_pose, double * d_ligand_pose,
    int * cluster, int * rec_name, int *lig_name,
    int num_glowworms, int swarms, int current_g, int num_atoms_rec, int num_atoms_lig
){
    const int block_idx = blockIdx.x;
    const int block_idy = blockIdx.y;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    __shared__ int smem[2048];
    int current_cluster = cluster[block_idy*num_glowworms];
    double * cluster_coord_rec = &d_receptor_pose[swarms * num_glowworms * num_atoms_rec * 3 + current_cluster * num_atoms_rec * 3];
    double * cluster_coord_lig = &d_ligand_pose[swarms * num_glowworms * num_atoms_lig * 3 + current_cluster * num_atoms_lig * 3];

    double * glowworms_coord_rec = &d_receptor_pose[swarms * num_glowworms * num_atoms_rec * 3 + current_g * num_atoms_rec * 3];
    double * glowworms_coord_lig = &d_ligand_pose[swarms * num_glowworms * num_atoms_lig * 3 + current_g * num_atoms_lig * 3];

    int n = block_idx * block_size + thread_idx;
    int N = num_atoms_rec + num_atoms_lig;
    double rmsd = 0;
    int backbone_len = 0;
    if(n<num_atoms_rec){
        rmsd += (cluster_coord_rec[n*3] - glowworms_coord_rec[n*3]) * (cluster_coord_rec[n*3] - glowworms_coord_rec[n*3]);
        rmsd += (cluster_coord_rec[n*3+1] - glowworms_coord_rec[n*3+1]) * (cluster_coord_rec[n*3+1] - glowworms_coord_rec[n*3+1]);
        rmsd += (cluster_coord_rec[n*3+2] - glowworms_coord_rec[n*3+2]) * (cluster_coord_rec[n*3+2] - glowworms_coord_rec[n*3+2]);
        backbone_len ++;
        rmsd *= rec_name[n];
        backbone_len *= rec_name[n];
    }
    if(n<N && n>=num_atoms_rec){
        int idx = n - num_atoms_rec;
        rmsd += (cluster_coord_lig[idx*3] - glowworms_coord_lig[idx*3]) * (cluster_coord_lig[idx*3] - glowworms_coord_lig[idx*3]);
        rmsd += (cluster_coord_lig[idx*3+1] - glowworms_coord_lig[idx*3+1]) * (cluster_coord_lig[idx*3+1] - glowworms_coord_lig[idx*3+1]);
        rmsd += (cluster_coord_lig[idx*3+2] - glowworms_coord_lig[idx*3+2]) * (cluster_coord_lig[idx*3+2] - glowworms_coord_lig[idx*3+2]);
        backbone_len++;
        rmsd *= lig_name[idx];
        backbone_len *= lig_name[idx];
    }

    // block_reduce
    int * s_backbone_len = (int *)smem;
    double * s_rmsd = (double *)(smem + 1024);

    s_backbone_len[thread_idx] = (n<N)? backbone_len : 0;
    s_rmsd[thread_idx] = (n<N)? rmsd : 0;
    __syncthreads();

    for(int offset = block_size >> 1; offset >= 32; offset >>=1){
        if(thread_idx < offset){
            s_rmsd[thread_idx] += s_rmsd[thread_idx+offset];
            s_backbone_len[thread_idx] += s_backbone_len[thread_idx+offset];
        }
        __syncthreads();
    }

    double y = s_rmsd[thread_idx];
    double z = s_backbone_len[thread_idx];
    for(int offset = 16; offset > 0; offset>>=1){
        y+=__shfl_down_sync(FULL_MASK,y,offset);
        z+=__shfl_down_sync(FULL_MASK,z,offset);
    }
    if(thread_idx == 0){
        d_rmsd_tmp[block_idy * gridDim.x + block_idx] = y;
        d_backbone_tmp[block_idy * gridDim.x + block_idx] = z;
    }

}

__global__ void cal_final_rmsd(
    double * d_rmsd, double * d_rmsd_tmp, int * d_backbone_tmp, int num_glowworms, int len
){
    // const int block_idy = blockIdx.y;
    const int block_idx = blockIdx.x;
    const int grid_x = gridDim.x;
    const int thread_idx = threadIdx.x;
    const int block_size = blockDim.x;
    __shared__ int smem[2048];
    int * s_backup_tmp = (int *)smem;
    double * s_rmsd_tmp = (double *)(smem + 1024);
    int n = block_idx * len + thread_idx;
    int N = num_glowworms * len;
    s_backup_tmp[thread_idx] = (n<N)? d_backbone_tmp[n] : 0;
    s_rmsd_tmp[thread_idx] = (n<N)? d_rmsd_tmp[n] : 0;
    __syncthreads();

    for(int offset = block_size >> 1; offset >= 32; offset >>=1){
        if(thread_idx < offset){
            s_rmsd_tmp[thread_idx] += s_rmsd_tmp[thread_idx+offset];
            s_backup_tmp[thread_idx] += s_backup_tmp[thread_idx+offset];
        }
        __syncthreads();
    }

    double y = s_rmsd_tmp[thread_idx];
    int z = s_backup_tmp[thread_idx];
    for(int offset = 16; offset > 0; offset>>=1){
        y+=__shfl_down_sync(FULL_MASK,y,offset);
        z+=__shfl_down_sync(FULL_MASK,z,offset);
    }

    if(thread_idx==0){
        d_rmsd[block_idx] = sqrt(y/z);
    }

}

void cal_gso_tasks_gpu(SwarmCenters & centers,Complex & receptor, Complex &lignad, FastDifire & fastdifire, int seed, double step_translation, double step_rotation, bool use_anm, double nmodes_step,
    int anm_rec, int anm_lig, bool local_minimization, int swarms, int num_glowworms, double * receptor_reference_points, double * receptor_poles, double * ligand_reference_points, double * ligand_poles,
    int *dfire_objects_rec, int *dfire_objects_lig,
    int object_size_rec, int object_size_lig)
{
    int num_threads = get_env_num_threads();
    DockingInterface rec_interface, lig_interface;
    
    // // run dock

    // Glowworm * glowworms = new Glowworm[swarms*num_glowworms];
    // glowworm  soa
    int * id_base = new int [swarms*num_glowworms];
    double * scoring_base = new double[swarms*num_glowworms];
    double * luciferin_base = new double [swarms*num_glowworms];
    double * rho_base = new double [swarms*num_glowworms];
    double * gamma_base = new double [swarms*num_glowworms];
    double * beta_base = new double [swarms*num_glowworms];
    double * vision_range_base = new double[swarms*num_glowworms];
    double * max_vision_range_base = new double [swarms*num_glowworms];
    int * step_base = new int  [swarms*num_glowworms];
    int * moved_base  = new int  [swarms*num_glowworms];
    int * max_neighbors_base = new int [swarms*num_glowworms];
    int * nnei_len_base = new int[swarms*num_glowworms];
    int * neighbors_base = new int [swarms*num_glowworms*num_glowworms];

    // 赋值

    for (int i = 0; i < swarms*num_glowworms; i++)
    {
        id_base[i] = 0;
        scoring_base[i] = 0;
        luciferin_base[i] = 5.0;
        rho_base[i] = 0.4;
        gamma_base[i] = 0.6;
        beta_base[i] = 0.08;
        vision_range_base[i] = 0.2;
        max_vision_range_base[i] = 5.0;
        step_base[i] = 0;
        moved_base[i] = 0;
        max_neighbors_base[i] = 5;
        nnei_len_base[i] = 0;
    }

    double * receptor_pose = new double [swarms*receptor.num_atoms*3];
    double * ligand_pose = new double [swarms*lignad.num_atoms*3];
    double * ligand_reference_pose = new double[swarms*num_glowworms*3];
    double * rec_copy_base = new double [swarms*num_glowworms*receptor.num_atoms*3];
    double * lig_copy_base = new double [swarms*num_glowworms*lignad.num_atoms*3];
    int * select_base = new int [swarms * num_glowworms];
    double * select_postition_base = new double [swarms * num_glowworms*(7+centers.anm_rec+centers.anm_lig)];
    double * delta_base = new double [swarms * 3];
    double * prob_array = new double [STEPS * swarms * num_glowworms];
    
    std::uniform_real_distribution<double> distribution(0.0, 1.0);
    std::mt19937 gen(0);
    for(int i = 0; i<swarms; i++){
        for(int g = 0; g<num_glowworms; g++){
            id_base[i*num_glowworms+g] = g;
        }
    }
    // 构造 random array
    
    for (int i = 0; i< swarms; i++){
        for(int s = 0; s<STEPS; s++){
            for(int j = 0; j<num_glowworms; j++ ){
                double value  = distribution(gen);
                prob_array[i*STEPS*num_glowworms + s*num_glowworms + j] = value;
            }
        }
    }
    double * d_receptor_pose, * d_ligand_pose, * d_ligand_reference_pose ,  *d_select_position_base, *d_probabilities, *d_energy, * d_energy_tmp,
    * d_delta_base,*d_scoring_base, *d_luciferin_base, *d_rho_base, *d_gamma_base, *d_beta_base, *d_vision_range_base, *d_max_vision_range_base, 
    *d_prob_array, * d_centers_pos, * d_receptor_atom_coordinates, *d_ligand_atom_coordinates, *d_current_ligand_reference_pose, *d_receptor_modes, *d_ligand_modes,
    *rotate_inverse, * current_pos, * current_pos2, *d_fastdfire, * d_rec_base, * d_lig_base;
    int *d_id_base, *d_step_base, *d_moved_base, *d_max_neighbors_base, *d_nnei_len_base, * d_selece_base,
    *d_neighbors_base, * d_receptor_mask, *d_ligand_mask, *d_dfire_objects_rec, *d_dfire_objects_lig;
    unsigned int * indexes, *array_index, * d_dist_to_bins;


    
    int block_size = 256;

    int grid_x_r = (receptor.num_atoms + block_size - 1) / block_size;
    int grid_x_l = (lignad.num_atoms + block_size - 1) / block_size;
    int grid_y = num_glowworms;
    int grid_z = swarms;
    // dim3 block(block_size, 1, 1);
    dim3 grid_r(grid_x_r,grid_y,grid_z);
    dim3 grid_l(grid_x_l,grid_y,grid_z);
    dim3 grid_score(grid_y,grid_z,1);
    

    
    CHECK(cudaMalloc((void **) &d_receptor_pose,swarms*num_glowworms*receptor.num_atoms*3*sizeof(double)));
    CHECK(cudaMalloc((void **) &d_ligand_pose,swarms*num_glowworms*lignad.num_atoms*3*sizeof(double)));
    CHECK(cudaMalloc((void **) &d_ligand_reference_pose,swarms*num_glowworms*3*sizeof(double)));
    CHECK(cudaMalloc((void **) &d_energy_tmp,swarms*num_glowworms*grid_x_r*sizeof(double)));
    CHECK(cudaMalloc((void **) &d_delta_base,swarms * num_glowworms * 3*sizeof(double)));
    CHECK(cudaMalloc((void **) &d_centers_pos, sizeof(double) * swarms*centers.pos_len));
    CHECK(cudaMalloc((void **) &d_select_position_base, sizeof(double)*swarms*centers.pos_len));
    CHECK(cudaMalloc((void**)&d_id_base, sizeof(int) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_scoring_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_luciferin_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_rho_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_gamma_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_beta_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_vision_range_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_max_vision_range_base, sizeof(double) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_step_base, sizeof(int) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_moved_base, sizeof(int) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_max_neighbors_base, sizeof(int) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_nnei_len_base, sizeof(int) * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_neighbors_base, sizeof(int) * swarms * num_glowworms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_prob_array, sizeof(double) * STEPS * swarms * num_glowworms));
    CHECK(cudaMalloc((void**)&d_dist_to_bins,sizeof(unsigned int) * 50));
    CHECK(cudaMalloc((void**)&d_selece_base,sizeof(int)*swarms*num_glowworms));
    CHECK(cudaMalloc((void**)&d_probabilities,sizeof(double)*swarms*num_glowworms*num_glowworms));
    CHECK(cudaMalloc((void **)&d_rec_base, sizeof(double)*swarms*num_glowworms*centers.anm_rec));
    CHECK(cudaMalloc((void **)&d_lig_base, sizeof(double)*swarms*num_glowworms*centers.anm_lig));

    //  std::cout<<"00"<<std::endl;
    // receptor

    CHECK(cudaMalloc((void **)& d_receptor_atom_coordinates, sizeof(double)*receptor.num_atoms*3));
    CHECK(cudaMalloc((void **)& d_ligand_atom_coordinates, sizeof(double)*lignad.num_atoms*3));
    CHECK(cudaMalloc((void **)& d_current_ligand_reference_pose, sizeof(double)*3));
    CHECK(cudaMalloc((void **)& d_receptor_modes, sizeof(double)*DEFAULT_NMODES_REC*receptor.num_atoms*3));
    CHECK(cudaMalloc((void **)& d_ligand_modes, sizeof(double)*DEFAULT_NMODES_LIG*lignad.num_atoms*3));
    CHECK(cudaMalloc((void **)& d_receptor_mask, sizeof(int)*receptor.num_atoms));
    CHECK(cudaMalloc((void **)& d_ligand_mask, sizeof(int)*lignad.num_atoms));
    
    // rotate dfire
// TODO: 没有释放
    // CHECK(cudaMalloc((void **)& rotate_inverse,sizeof(double)*4*swarms * num_glowworms));
    // CHECK(cudaMalloc((void **)& current_pos, sizeof(double)*4*swarms * num_glowworms));
    // CHECK(cudaMalloc((void **)& current_pos2, sizeof(double)*4*swarms * num_glowworms));
    // std::cout<<"000"<<std::endl;
    // 
    
    CHECK(cudaMalloc((void **)& d_fastdfire, sizeof(double)*168*168*20));
    CHECK(cudaMalloc((void **)& d_dfire_objects_rec,sizeof(int)*object_size_rec));
    CHECK(cudaMalloc((void **)& d_dfire_objects_lig,sizeof(int)*object_size_lig));
    

    int64_t * d_sorted_glowworms_base;
    int64_t * d_sorted_glowworms_out;
    cudaMalloc(&d_sorted_glowworms_base, sizeof(int64_t)*swarms * num_glowworms);
    cudaMalloc(&d_sorted_glowworms_out, sizeof(int64_t)*swarms*num_glowworms);



    // 复制数据到设备
    cudaMemcpy(d_id_base, id_base, sizeof(int) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_scoring_base, scoring_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_luciferin_base, luciferin_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_rho_base, rho_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_gamma_base, gamma_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_beta_base, beta_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_vision_range_base, vision_range_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_max_vision_range_base, max_vision_range_base, sizeof(double) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_step_base, step_base, sizeof(int) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_moved_base, moved_base, sizeof(int) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_max_neighbors_base, max_neighbors_base, sizeof(int) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_nnei_len_base, nnei_len_base, sizeof(int) * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_prob_array, prob_array, sizeof(double) * STEPS * swarms * num_glowworms, cudaMemcpyHostToDevice);
    cudaMemcpy(d_centers_pos, centers.pos, sizeof(double)*swarms* centers.pos_len,cudaMemcpyHostToDevice);
    cudaMemcpy(d_receptor_atom_coordinates, receptor.atom_coordinates, sizeof(double)*receptor.num_atoms*3, cudaMemcpyHostToDevice);
    cudaMemcpy(d_ligand_atom_coordinates, lignad.atom_coordinates, sizeof(double)*lignad.num_atoms*3, cudaMemcpyHostToDevice);
    cudaMemcpy(d_current_ligand_reference_pose, ligand_reference_points, sizeof(double)*3,cudaMemcpyHostToDevice);
    cudaMemcpy(d_receptor_mask, receptor.mask,sizeof(int)*receptor.num_atoms,cudaMemcpyHostToDevice);
    cudaMemcpy(d_ligand_mask, lignad.mask,sizeof(int)*lignad.num_atoms,cudaMemcpyHostToDevice);
    cudaMemcpy(d_fastdfire, fastdifire.difire_energy, sizeof(double)*168*168*20,cudaMemcpyHostToDevice);
    cudaMemcpy(d_dfire_objects_rec,dfire_objects_rec,sizeof(int)*object_size_rec,cudaMemcpyHostToDevice );
    cudaMemcpy(d_dfire_objects_lig,dfire_objects_lig,sizeof(int)*object_size_lig,cudaMemcpyHostToDevice);
    cudaMemcpy(d_dist_to_bins, dist_to_bins,sizeof(unsigned int) * 50, cudaMemcpyHostToDevice);

    cudaMemcpy(d_ligand_modes, lignad.modes, sizeof(double) * DEFAULT_NMODES_LIG * lignad.num_atoms*3, cudaMemcpyHostToDevice);
    cudaMemcpy(d_receptor_modes, receptor.modes, sizeof(double)* DEFAULT_NMODES_REC * receptor.num_atoms*3, cudaMemcpyHostToDevice);

    // float prepare_receptor, prepare_ligand, cal_dfire, t_score, cal_neighbor, cal_move, write_centerpos, t_pdb, cluster;
    float t[9];
    memset(t,0,sizeof(float)*9);
    // prepare_receptor=0;
    // prepare_ligand = 0;
    // cal_dfire = 0;
    // t_score = 0;
    // write_centerpos = 0;
    // t_pdb = 0;
    // cluster = 0;
    // cal_neighbor= 0;
    // cal_move = 0;
    cudaEvent_t start, stop;
    cudaEventCreate(&start);
    cudaEventCreate(&stop);
    // std::cout<<PROJECT_PATH<<std::endl;
    for(int step = 0; step<STEPS; step++){
        std::cout<<"step:"<<step<<std::endl;

        CHECK(cudaEventRecord(start));
        cudaEventQuery(start);
        cudaMemset(d_energy,0,sizeof(double)*swarms*num_glowworms);
        prepare_receptor_pose<<<grid_r,block_size>>>(
             d_centers_pos, d_receptor_pose, 
            d_receptor_atom_coordinates, 
            d_receptor_modes, 
            d_receptor_mask,
            d_moved_base, d_step_base,
            swarms, num_glowworms,  centers.anm_lig, centers.anm_rec,
            receptor.num_atoms
        );
        CHECK(cudaEventRecord(stop));
        CHECK(cudaEventSynchronize(stop));
        float prepare_time;
        CHECK(cudaEventElapsedTime(&prepare_time, start, stop));
        t[0] += prepare_time;
        // cudaDeviceSynchronize();

        CHECK(cudaEventRecord(start));
        cudaEventQuery(start);
        prepare_lignad_pose<<<grid_l,block_size>>>(
            d_centers_pos,  d_ligand_pose,  d_ligand_reference_pose, 
            d_ligand_atom_coordinates,  
            d_current_ligand_reference_pose, 
            d_ligand_modes,
            d_ligand_mask,
            d_moved_base, d_step_base,
            swarms, num_glowworms,  centers.anm_lig, centers.anm_rec,
            lignad.num_atoms
        );
        CHECK(cudaEventRecord(stop));
        CHECK(cudaEventSynchronize(stop));
        float prepare_l_time;
        CHECK(cudaEventElapsedTime(&prepare_l_time, start, stop));
        t[1] += prepare_l_time;

        // cudaDeviceSynchronize();
        CHECK(cudaEventRecord(start));
        cudaEventQuery(start);
        calculate_dfire<<<grid_r,block_size>>>(
            d_receptor_pose, d_ligand_pose, 
            d_scoring_base, d_luciferin_base, d_rho_base, d_gamma_base,
            d_energy_tmp,
            d_moved_base, d_step_base,
            d_fastdfire, d_dfire_objects_rec, d_dfire_objects_lig, d_dist_to_bins,
            swarms, num_glowworms,  centers.anm_lig, centers.anm_rec,
            receptor.num_atoms, lignad.num_atoms
        );
        CHECK(cudaEventRecord(stop));
        CHECK(cudaEventSynchronize(stop));
        float dfire_time;
        CHECK(cudaEventElapsedTime(&dfire_time, start, stop));
        t[2] += dfire_time;


        cudaMemcpy(dfire_objects_rec,d_dfire_objects_rec,sizeof(int)*object_size_rec,cudaMemcpyDeviceToHost);
        cudaMemcpy(dfire_objects_lig, d_dfire_objects_lig,sizeof(int)*object_size_lig,cudaMemcpyDeviceToHost);

        write_mati(dfire_objects_rec, object_size_rec, 1, "rec_object");
        write_mati(dfire_objects_lig, object_size_lig, 1, "lig_object");
        std::cout<<object_size_rec<<std::endl;
        std::cout<<object_size_lig<<std::endl;

        std::cout<<receptor.num_atoms<<std::endl;
        std::cout<<lignad.num_atoms<<std::endl;

        exit(0);
        // cudaDeviceSynchronize();
        
        CHECK(cudaEventRecord(start));
        cudaEventQuery(start);
        cal_score<<<grid_score,grid_x_r>>>(
            
            d_scoring_base, d_luciferin_base, d_rho_base, d_gamma_base,
            d_energy_tmp,
            d_moved_base, d_step_base,
            swarms, num_glowworms,  centers.anm_lig, centers.anm_rec,
            receptor.num_atoms, lignad.num_atoms,grid_x_r
        );
        CHECK(cudaEventRecord(stop));
        CHECK(cudaEventSynchronize(stop));
        float score_time;
        CHECK(cudaEventElapsedTime(&score_time, start, stop));
        t[3] += score_time;


        CHECK(cudaEventRecord(start));
        cudaEventQuery(start);
        cal_move_neighbors<<<swarms, num_glowworms>>>(
            d_select_position_base, d_neighbors_base, d_vision_range_base, d_selece_base, d_nnei_len_base,
            d_luciferin_base, d_probabilities, d_prob_array, d_centers_pos, d_ligand_reference_pose,
            swarms, num_glowworms, anm_lig, anm_rec,
            lignad.num_atoms,step
        );
        CHECK(cudaEventRecord(stop));
        CHECK(cudaEventSynchronize(stop));
        float neighbor_time;
        CHECK(cudaEventElapsedTime(&neighbor_time, start, stop));
        t[4] += neighbor_time;
        // cudaDeviceSynchronize();
        
        // cudaMemcpy(select_postition_base,d_select_position_base, sizeof(double) * swarms*num_glowworms*(7+centers.anm_rec+centers.anm_lig), cudaMemcpyDeviceToHost);
        // write_mat(select_postition_base, swarms, num_glowworms*(7+centers.anm_rec+centers.anm_lig), "gpu_luciferin.txt");
        // exit(0);
        CHECK(cudaEventRecord(start));
        cudaEventQuery(start);
        move_position<<<swarms,num_glowworms>>>(
        d_vision_range_base, d_centers_pos, d_select_position_base, 
        d_id_base, d_selece_base, d_delta_base, d_rec_base, d_lig_base,
        d_beta_base, d_max_neighbors_base,
        d_max_vision_range_base, d_nnei_len_base,
        d_moved_base, swarms, num_glowworms,anm_lig,  anm_rec,
         lignad.num_atoms,step
        );
        cudaDeviceSynchronize();
        CHECK(cudaEventRecord(stop));
        CHECK(cudaEventSynchronize(stop));
        float move_time;
        CHECK(cudaEventElapsedTime(&move_time, start, stop));
        t[5] += move_time;


    }

    // center.pos, receptor_pose, ligand_pose, 
    cudaDeviceSynchronize();
    cudaMemcpy(centers.pos,d_centers_pos, sizeof(double)*swarms* centers.pos_len,cudaMemcpyDeviceToHost);
    cudaMemcpy(luciferin_base,d_luciferin_base, sizeof(double)*swarms* num_glowworms,cudaMemcpyDeviceToHost);
    cudaMemcpy(nnei_len_base,d_nnei_len_base,sizeof(double)*swarms* num_glowworms,cudaMemcpyDeviceToHost);
    cudaMemcpy(vision_range_base,d_vision_range_base, sizeof(double)*swarms* num_glowworms,cudaMemcpyDeviceToHost);
    cudaMemcpy(scoring_base,d_scoring_base, sizeof(double)*swarms* num_glowworms,cudaMemcpyDeviceToHost);
    //  write_mat(centers.pos, swarms, centers.pos_len, "gpu_luciferin.txt");
    // exit(0);
    // exit(0);
    printf("finished. \n");
    
    // 
    prepare_receptor<<<grid_r,block_size>>>(
        d_receptor_pose, d_receptor_atom_coordinates, d_centers_pos, d_receptor_modes,
        d_receptor_mask,
        swarms, num_glowworms, centers.anm_lig, centers.anm_rec, receptor.num_atoms
    );
    prepare_ligand<<<grid_l,block_size>>>(
        d_ligand_pose, d_ligand_atom_coordinates, d_centers_pos, d_ligand_modes, d_ligand_mask, swarms, num_glowworms,centers.anm_lig, centers.anm_rec,lignad.num_atoms
    );

    CHECK(cudaEventRecord(start));
    cudaEventQuery(start);
    #pragma omp parallel for 
    for(int i = 0; i<swarms; i++){


        double *current_pos = &centers.pos[i*centers.pos_len];
        

        int select_index = 0;
        double * select_postion = &select_postition_base[i*num_glowworms*(7+centers.anm_rec+centers.anm_lig)];
        double * delta = &delta_base[i*3];


        string save_swarm = "swarm_";
        string file_name = "gso_";
        string swarms = to_string(i);
        string steps = to_string(STEPS) ;
        string file_type = ".out";
        string save_dir =  save_swarm+swarms;
        string save_file = file_name+steps+file_type;
        // std::cout<<save_file<<std::endl;
        string slash = "/";
        string full_path = save_dir+slash+save_file;
        int fd = open(full_path.c_str(), O_RDWR | O_CREAT, 0666);
        if(fd == -1){
            perror("open");
            exit(1);
        }
        
        // std::ofstream newFile(full_path.c_str());
        
        string file_buffer = "#Coordinates  RecID  LigID  Luciferin  Neighbor's number  Vision Range  Scoring\n";
        
        for(int g = 0; g<num_glowworms;g++){
            string line = "(";
            double * current_postion = &current_pos[g*(7+centers.anm_rec+centers.anm_lig)];
            for(int pp = 0; pp < (7+centers.anm_rec+centers.anm_lig); pp++){
                line = line + to_string(current_postion[pp]);
                if(pp<(7+centers.anm_rec+centers.anm_lig)-1){
                    line = line + ", ";
                }
                
            }
            line = line +")\t";
            line = line + to_string(0) + "\t";
            line = line + to_string(0) + "\t";
            line = line + to_string(luciferin_base[i*num_glowworms+g]) + "\t";
            line = line + to_string(nnei_len_base[i*num_glowworms+g]) + "\t";
            line = line + to_string(vision_range_base[i*num_glowworms+g]) + "\t";
            line = line + to_string(scoring_base[i*num_glowworms+g]) + "\t";
            line = line +"\n";
            file_buffer  = file_buffer + line;
            // newFile<<"\n";
        }
        int str_len = strlen(file_buffer.c_str());
        // std::cout<<str_len<<std::endl;
        lseek(fd,str_len-1,SEEK_END);  
        write(fd, "", 1);

        char *p = (char *)mmap(NULL, str_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        if (p == MAP_FAILED) {
            perror("mmap");
            exit(1);
        }
        
        memcpy(p, file_buffer.c_str(),str_len);
        munmap(p, str_len);
        close(fd);
    }
    CHECK(cudaEventRecord(stop));
    CHECK(cudaEventSynchronize(stop));
    float center_pos_time;
    CHECK(cudaEventElapsedTime(&center_pos_time, start, stop));
    t[6] += center_pos_time;
    printf("finished. \n");

    
    
    cudaMemcpy(rec_copy_base,d_receptor_pose,sizeof(double)* swarms*num_glowworms*receptor.num_atoms*3,cudaMemcpyDeviceToHost);
    cudaMemcpy(lig_copy_base,d_ligand_pose,sizeof(double)* swarms*num_glowworms*lignad.num_atoms*3,cudaMemcpyDeviceToHost);

    
    

    CHECK(cudaEventRecord(start));
    cudaEventQuery(start);
    // 异步写
    // std::cout<<num_threads<<std::endl;
    #pragma omp parallel for num_threads(num_threads)
    for(int i = 0; i<swarms; i++){
        double * rec_copy = &rec_copy_base[i*num_glowworms*receptor.num_atoms*3];
        double * lig_copy = &lig_copy_base[i*num_glowworms*lignad.num_atoms*3];
        for(int g = 0; g<num_glowworms; g++){
            double * current_rec_copy = &rec_copy[g*receptor.num_atoms*3];
            double * current_lig_copy = &lig_copy[g*lignad.num_atoms*3];
            string save_swarm = "swarm_";
            string file_name = "lightdock_";
            string swarms = to_string(i);
            string steps = to_string(g) ;
            string file_type = ".pdb";
            string save_dir =  save_swarm+swarms;
            string save_file = file_name+steps+file_type;
            // std::cout<<save_file<<std::endl;
            string slash = "/";
            string full_path = save_dir+slash+save_file;
            // TODO: 写文件
            int fd = open(full_path.c_str(), O_RDWR | O_CREAT, 0666);
            if(fd == -1){
                perror("open");
                exit(1);
            }
            // std::ofstream newFile(full_path.c_str());
            for(int nn = 0; nn<receptor.num_atoms; nn++){
                string type = receptor.atoms[nn].type;
                string number = to_string(nn+1);
                number = string(5 - number.length(), ' ') + number;
                string atom_name = receptor.atoms[nn].name;
                if(atom_name.length()<4){
                    atom_name = " "+atom_name;
                }
                // std::cout<<receptor.atoms[nn].alternative<<1212<<std::endl;
                atom_name = atom_name+string(4 - atom_name.length(), ' ');
                string alternative = receptor.atoms[nn].alternative + string(1 - receptor.atoms[nn].alternative.length(), ' ');

                string residue_name = receptor.atoms[nn].residue_name;
                residue_name = string(3 - residue_name.length(),' ') + residue_name ;
                string chain_id = receptor.atoms[nn].chain_id;
                chain_id = string(2 - chain_id.length(), ' ')+chain_id;

                string residue_number = to_string(receptor.atoms[nn].residue_number);
                residue_number = string(4 - residue_number.length(),' ') + residue_number ;
                string residue_insertion = receptor.atoms[nn].residue_insertion;
                residue_insertion = string(1 - residue_insertion.length(),' ') + residue_insertion ;

                string blank = "   ";

                double xx = current_rec_copy[nn*3];
                double yy = current_rec_copy[nn*3+1];
                double zz = current_rec_copy[nn*3+2];
                std::stringstream ss;
                ss << std::fixed << std::setprecision(3) << xx;  // 设置小数点精度为3位
                string xx_str = ss.str();
                xx_str = string(8 - xx_str.length(),' ') + xx_str ;

                std::stringstream ss_y;
                ss_y << std::fixed << std::setprecision(3) << yy;  // 设置小数点精度为3位
                string yy_str = ss_y.str();
                yy_str = string(8 - yy_str.length(),' ') + yy_str ;

                std::stringstream ss_z;
                ss_z << std::fixed << std::setprecision(3) << zz;  // 设置小数点精度为3位
                string zz_str = ss_z.str();
                zz_str = string(8 - zz_str.length(),' ') + zz_str ;

                double occupancy = receptor.atoms[nn].occupancy;
                std::stringstream s_o;
                s_o << std::fixed << std::setprecision(2) << occupancy;
                string oo = s_o.str();
                oo = string(6 - oo.length(),' ') + oo ;

                double b_factor = receptor.atoms[nn].b_factor;
                std::stringstream s_b;
                s_b << std::fixed << std::setprecision(2) << b_factor;
                string bb = s_b.str();
                bb = string(6 - bb.length(),' ') + bb ;

                string element = receptor.atoms[nn].element;
                element = string(12 - element.length(),' ') + element ;
                // TODO: 重复
                
                // zz_str = string(8 - zz_str.length(),' ') + zz_str ;

                // string residue_name = receptor.atoms[nn].residue_name;
                string lines = type + number + " "+atom_name+ alternative+ residue_name+chain_id
                    + residue_number+residue_insertion+blank+xx_str+yy_str+zz_str+oo+bb+element+"\n";
                int len = strlen(lines.c_str());
                write(fd, lines.c_str(), len);
                // newFile << type + number + " "+atom_name+ alternative+ residue_name+chain_id
                //     + residue_number+residue_insertion+blank+xx_str+yy_str+zz_str+oo+bb+element+"\n";
            }   
            for(int nn = 0; nn<lignad.num_atoms; nn++){
                string type = lignad.atoms[nn].type;
                string number = to_string(nn+1);
                number = string(5 - number.length(), ' ') + number;
                string atom_name = lignad.atoms[nn].name;
                if(atom_name.length()<4){
                    atom_name = " "+atom_name;
                }
                // std::cout<<receptor.atoms[nn].alternative<<1212<<std::endl;
                atom_name = atom_name+string(4 - atom_name.length(), ' ');
                string alternative = lignad.atoms[nn].alternative + string(1 - lignad.atoms[nn].alternative.length(), ' ');

                string residue_name = lignad.atoms[nn].residue_name;
                residue_name = string(3 - residue_name.length(),' ') + residue_name ;
                string chain_id = lignad.atoms[nn].chain_id;
                chain_id = string(2 - chain_id.length(), ' ')+chain_id;

                string residue_number = to_string(lignad.atoms[nn].residue_number);
                residue_number = string(4 - residue_number.length(),' ') + residue_number ;
                string residue_insertion = lignad.atoms[nn].residue_insertion;
                residue_insertion = string(1 - residue_insertion.length(),' ') + residue_insertion ;

                string blank = "   ";

                double xx = current_lig_copy[nn*3];
                double yy = current_lig_copy[nn*3+1];
                double zz = current_lig_copy[nn*3+2];
                std::stringstream ss;
                ss << std::fixed << std::setprecision(3) << xx;  // 设置小数点精度为3位
                string xx_str = ss.str();
                xx_str = string(8 - xx_str.length(),' ') + xx_str ;

                std::stringstream ss_y;
                ss_y << std::fixed << std::setprecision(3) << yy;  // 设置小数点精度为3位
                string yy_str = ss_y.str();
                yy_str = string(8 - yy_str.length(),' ') + yy_str ;

                std::stringstream ss_z;  
                ss_z << std::fixed << std::setprecision(3) << zz;  // 设置小数点精度为3位
                string zz_str = ss_z.str();
                zz_str = string(8 - zz_str.length(),' ') + zz_str ;

                double occupancy = lignad.atoms[nn].occupancy;
                std::stringstream s_o;
                s_o << std::fixed << std::setprecision(2) << occupancy;
                string oo = s_o.str();
                oo = string(6 - oo.length(),' ') + oo ;

                double b_factor = lignad.atoms[nn].b_factor;
                std::stringstream s_b;
                s_b << std::fixed << std::setprecision(2) << b_factor;
                string bb = s_b.str();
                bb = string(6 - bb.length(),' ') + bb ;

                string element = lignad.atoms[nn].element;
                element = string(12 - element.length(),' ') + element ;
                // TODO: 重复
                
                // zz_str = string(8 - zz_str.length(),' ') + zz_str ;

                // string residue_name = receptor.atoms[nn].residue_name;
                string lines = type + number + " "+atom_name+ alternative+ residue_name+chain_id
                    + residue_number+residue_insertion+blank+xx_str+yy_str+zz_str+oo+bb+element+"\n";
                int len = strlen(lines.c_str());
                write(fd, lines.c_str(), len);
            }       
            // write_pdb(receptor,newFile,current_rec_copy);
            // write_pdb(lignad,newFile,current_lig_copy);
            // newFile.close();
            close(fd);
        }
    }
    CHECK(cudaEventRecord(stop));
    CHECK(cudaEventSynchronize(stop));
    float pdb_time;
    CHECK(cudaEventElapsedTime(&pdb_time, start, stop));
    t[7] += pdb_time;

    CHECK(cudaEventRecord(start));
    cudaEventQuery(start);

    CHECK(cudaEventRecord(start));
    cudaEventQuery(start);

    int * cluster_len_base = new int [swarms * num_glowworms];
    int * cluster_base = new int[swarms * num_glowworms * num_glowworms];
    int64_t * sort_pair = new int64_t[swarms * num_glowworms];
    int * in_cluster_base = new int[swarms * num_glowworms];
    memset(in_cluster_base,0,sizeof(int)*swarms * num_glowworms);
    
    // d_glowworms * sorted_glowworms_base = new d_glowworms [swarms * num_glowworms];
    // cluster index
    int * cluster_index = new int[swarms];
    const int ITEM_PER_THREAD = 1;
    const int b_sort_size =  256;
    const int BLOCK_THREADS = b_sort_size / ITEM_PER_THREAD;
    prepare_pair<<<swarms, num_glowworms>>>(d_sorted_glowworms_base,d_id_base, d_scoring_base,num_glowworms);

    BlockSortKernel<int64_t, BLOCK_THREADS, ITEM_PER_THREAD> <<<swarms, BLOCK_THREADS>>>(d_sorted_glowworms_base, d_sorted_glowworms_out);


    int * rec_name = new int [receptor.num_atoms];
    int * lig_name = new int [lignad.num_atoms];
    for(int i = 0; i<receptor.num_atoms;i++){
        if(receptor.atom_name[i] == "CA" || receptor.atom_name[i] == "P"){
            rec_name[i] = 1;
        }
        else{
            rec_name[i] = 0;
        }
        
    }
    for(int i = 0;i<lignad.num_atoms;i++){
        if(lignad.atom_name[i] == "CA" || lignad.atom_name[i] == "P"){
            lig_name[i] = 1;
        }else{
            lig_name[i] = 0;
        }
        
    }
    

    cudaMemcpy(sort_pair, d_sorted_glowworms_out, sizeof(int64_t)*swarms * num_glowworms, cudaMemcpyDeviceToHost);

    printf("finished.1111 \n");
    int64_t mask = 0x0000000000000FFF;

    double * l_rmsd = new double [swarms * num_glowworms * num_glowworms];
    int * l_bakbone = new int [swarms * num_glowworms * num_glowworms];
    double * l_rmsd_base  = new double [swarms * num_glowworms];

    int total_len = receptor.num_atoms + lignad.num_atoms;
    memset(l_rmsd,0, sizeof(double) * swarms * num_glowworms * num_glowworms);
    memset(l_bakbone, 0, sizeof(int) * swarms * num_glowworms * num_glowworms);

    #pragma omp parallel for
    for(int i = 0; i<swarms; i++){
        double * rec_copy = &rec_copy_base[i*num_glowworms*receptor.num_atoms*3];
        double * lig_copy = &lig_copy_base[i*num_glowworms*lignad.num_atoms*3];
 
        // 聚类
        int64_t * sorted_glowworms = & sort_pair[i*num_glowworms];
        
        int * cluster = &cluster_base[i*num_glowworms * num_glowworms];

        cluster[0] =  (int)(sorted_glowworms[0] & mask);
        cluster_index[i] = 1;
        // 每一个类别的数量
        int * cluster_len_idnex = &cluster_len_base[i*num_glowworms];
        memset(cluster_len_idnex, 0, sizeof(int)*num_glowworms);
        cluster_len_idnex[0]++;
        
        // 聚类
        
        // 对每一个cluster
        // cuda 流方式    
        // #pragma omp parallel for 
        for(int g = 0; g<num_glowworms; g++){

            int current_g = (int)(sorted_glowworms[g] & mask);

            // copy保存的坐标 当前glowworm的坐标
            double * g_coord_rec = &rec_copy[current_g*receptor.num_atoms*3];
            double * g_coord_lig = &lig_copy[current_g*lignad.num_atoms*3];
            bool in_cluster = false;

            for(int c = 0; c<cluster_index[i]; c++){
                
                int current_cluster = cluster[c*num_glowworms]; 
                //当前cluster取一个代表
                double * cluster_coord_rec = &rec_copy[current_cluster*receptor.num_atoms*3];
                double * cluster_coord_lig = &lig_copy[current_cluster*lignad.num_atoms*3];
                
                int backbone_len = l_bakbone[i*num_glowworms*num_glowworms + g*num_glowworms + c];
                double rmsd = l_rmsd[i*num_glowworms*num_glowworms + g*num_glowworms + c];

                for(int dd = 0; dd<total_len; dd++){
                    if(dd<receptor.num_atoms){
                        double rmsd_tmp = 0;
                        int backbone_temp = 1;
                        rmsd_tmp += (cluster_coord_rec[dd*3] - g_coord_rec[dd*3]) * (cluster_coord_rec[dd*3] - g_coord_rec[dd*3]);
                        rmsd_tmp += (cluster_coord_rec[dd*3+1] - g_coord_rec[dd*3+1]) * (cluster_coord_rec[dd*3+1] - g_coord_rec[dd*3+1]);
                        rmsd_tmp += (cluster_coord_rec[dd*3+2] - g_coord_rec[dd*3+2]) * (cluster_coord_rec[dd*3+2] - g_coord_rec[dd*3+2]);
                        // backbone_temp ++;
                        rmsd += rmsd_tmp * rec_name[dd];
                        backbone_len += backbone_temp *  rec_name[dd];
                    }
                    else{
                        int idx = dd - receptor.num_atoms;
                        double rmsd_tmp = 0;
                        int backbone_tmp = 1;
                        rmsd_tmp += (cluster_coord_lig[idx*3] - g_coord_lig[idx*3]) * (cluster_coord_lig[idx*3] - g_coord_lig[idx*3]);
                        rmsd_tmp += (cluster_coord_lig[idx*3+1] - g_coord_lig[idx*3+1]) * (cluster_coord_lig[idx*3+1] - g_coord_lig[idx*3+1]);
                        rmsd_tmp += (cluster_coord_lig[idx*3+2] - g_coord_lig[idx*3+2]) * (cluster_coord_lig[idx*3+2] - g_coord_lig[idx*3+2]);
                        // backbone_len++;
                        rmsd += rmsd_tmp * lig_name[idx];
                        backbone_len += backbone_tmp * lig_name[idx];
                    }
                }

                
                rmsd /= backbone_len;
                rmsd = sqrt(rmsd);

               
                if (rmsd <= 4.0){
                    // cluster[cluster_index] = glowworms[g].id;
                    // 当前聚类的长度
                    int cluster_len = cluster_len_idnex[c];
                    
                    cluster[c*num_glowworms+cluster_len] = current_g;
                    cluster_len_idnex[c] ++;
                    in_cluster = true;
                    break;
                }
            }
            
            if(!in_cluster){

                cluster[cluster_index[i]*num_glowworms] = current_g;
                cluster_len_idnex[cluster_index[i]] ++;
                cluster_index[i] ++;
            }

        }
    }



    printf("finished.1111 \n");
    #pragma omp parallel for
    for(int i = 0; i<swarms; i++){
        int * cluster = &cluster_base[i*num_glowworms * num_glowworms];
        int * cluster_len_idnex = &cluster_len_base[i*num_glowworms];
        // write info
        string save_swarm = "swarm_";
        string file_name = "gso_";
        string swarms = to_string(i);
        string steps = to_string(STEPS) ;
        string file_type = ".out";
        string save_dir =  save_swarm+swarms;
        string save_file = file_name+steps+file_type;
        // std::cout<<save_file<<std::endl;
        string slash = "/";
        string full_path = save_dir+slash+save_file;

        string filename = "cluster.repr";
        string cluster_file = save_dir+slash+filename;
        // std::cout<<full_path<<std::endl;
        
        std::ofstream c_fileout(cluster_file.c_str());

        if (c_fileout.is_open()) {
            // 写入文件内容
            for(int c = 0 ; c< cluster_index[i]; c++){
                int cluster_len = cluster_len_idnex[c];
                int id = cluster[c*num_glowworms];
                double scoring = scoring_base[id];
                
                c_fileout << c<<":"<<cluster_len<<":"<<scoring<<":"<<id<<":lightdock_"<<id<<".pdb\n";

            }

        }
            

        // 关闭文件
        c_fileout.close();


    }
    printf("finished. \n");
    CHECK(cudaEventRecord(stop));
    CHECK(cudaEventSynchronize(stop));
    float c_time;
    CHECK(cudaEventElapsedTime(&c_time, start, stop));
    t[8] += c_time;

    delete [] prob_array;
    delete [] l_rmsd_base;
    // delete [] glowworms;
    delete [] receptor_pose;
    delete [] ligand_pose;
    delete [] ligand_reference_pose;
    delete [] rec_copy_base;
    delete [] lig_copy_base;
    delete [] select_base;
    delete [] select_postition_base;
    delete [] delta_base;

    delete [] id_base;
    delete [] scoring_base;
    delete [] luciferin_base;
    delete [] rho_base;
    delete [] gamma_base;
    delete [] beta_base;
    delete [] vision_range_base;
    delete [] max_vision_range_base;
    delete [] step_base;
    delete [] moved_base;
    delete [] max_neighbors_base;
    delete [] nnei_len_base;
    delete [] neighbors_base;
    delete[] cluster_len_base;
    delete[] cluster_base;
    delete[] sort_pair;
    delete[] cluster_index;
    delete[] rec_name;
    delete[] lig_name;
    printf("finished. \n");
    printf("======================================================================");
    std::cout<<"prepare receptor time"<<t[0]<<std::endl;
    std::cout<<"prepare ligand time "<<t[1]<<std::endl;
    std::cout<<"calculate dfire score time"<<t[2]<<std::endl;
    std::cout<<"calculate score time"<<t[3]<<std::endl;
    std::cout<<"calculate neighbor time"<<t[4]<<std::endl;
    std::cout<<"calculate move time"<<t[5]<<std::endl;
    std::cout<<"save center pos tim"<<t[6]<<std::endl;
    std::cout<<"save pdb time"<<t[7]<<std::endl;
    std::cout<<"final cluster time"<<t[8]<<std::endl;
    printf("======================================================================");
    cudaFree(d_receptor_pose);
    cudaFree(d_ligand_pose);
    cudaFree(d_ligand_reference_pose);
    cudaFree(d_delta_base);
    cudaFree(d_centers_pos);
    cudaFree(d_select_position_base);
    cudaFree(d_id_base);
    cudaFree(d_scoring_base);
    cudaFree(d_luciferin_base);
    cudaFree(d_rho_base);
    cudaFree(d_gamma_base);
    cudaFree(d_beta_base);
    cudaFree(d_vision_range_base);
    cudaFree(d_max_vision_range_base);
    cudaFree(d_step_base);
    cudaFree(d_moved_base);
    cudaFree(d_max_neighbors_base);
    cudaFree(d_nnei_len_base);
    cudaFree(d_neighbors_base);
    cudaFree(d_prob_array);
    cudaFree(d_dist_to_bins);
    cudaFree(d_selece_base);
    cudaFree(d_probabilities);
    cudaFree(d_rec_base);
    cudaFree(d_lig_base);
    cudaFree(d_receptor_atom_coordinates);
    cudaFree(d_ligand_atom_coordinates);
    cudaFree(d_current_ligand_reference_pose);
    cudaFree(d_receptor_modes);
    cudaFree(d_ligand_modes);
    cudaFree(d_receptor_mask);
    cudaFree(d_ligand_mask);
    // cudaFree(rotate_inverse);
    // cudaFree(current_pos);
    // cudaFree(current_pos2);
    cudaFree(d_fastdfire);
    cudaFree(d_dfire_objects_rec);
    cudaFree(d_dfire_objects_lig);
    cudaFree(d_energy_tmp);
    cudaFree(d_sorted_glowworms_base);
    cudaFree(d_sorted_glowworms_out);


}
